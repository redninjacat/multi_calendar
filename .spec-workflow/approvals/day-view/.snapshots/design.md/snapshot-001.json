{
  "id": "snapshot_1771050387390_ooxl9d3ws",
  "approvalId": "approval_1771050387386_ctfiq1bne",
  "approvalTitle": "Day View Design Document",
  "version": 1,
  "timestamp": "2026-02-14T06:26:27.390Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Design Document: Day View\n\n## Overview\n\nThis design document details the technical implementation of `MCalDayView` - a vertical timeline calendar view displaying a single day's schedule. The day view presents time-based events in proportion to their duration, with automatic overlap detection and column-based layout for concurrent events.\n\nThe architecture follows established patterns from `MCalMonthView` (7,834 lines), reusing the `MCalDragHandler` state machine, `MCalEventController` integration, theme system, and context object patterns. The view supports:\n- Configurable time ranges (e.g., 8am-6pm, full 24-hour)\n- All-day events section at top with drag/resize (platform-restricted)\n- Timed events area with Google Calendar-style overlap layout\n- Current time indicator with automatic minute updates\n- Vertical scrolling with auto-scroll to current time\n- Drag-to-move (vertical + cross-day edge navigation)\n- Drag-to-resize (top/bottom edges + cross-day navigation)\n- Event type conversion (all-day ↔ timed via drag)\n- Complete keyboard navigation\n- Full RTL support throughout\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n\n- **DST-safe time calculations**: All time arithmetic uses `DateTime(year, month, day, hour, minute)` constructor pattern, NEVER `Duration(hours:)` or `Duration(days:)` addition. When adding time slots: `DateTime(y, m, d, h, m).add(Duration(minutes: n))` is acceptable for intra-day calculations.\n- **ChangeNotifier reactivity**: Reuses existing `MCalDragHandler` (extends `ChangeNotifier`) for drag/resize state, ensuring view rebuilds follow the established reactive update path.\n- **intl localization**: Time formatting via `DateFormat` from intl package, hour labels respect locale (12/24-hour format).\n- **flutter_lints**: All public APIs get full dartdoc with examples.\n- **Performance**: O(n²) or better overlap detection, 60fps rendering with 50+ events, debounced drag updates (16ms).\n\n### Project Structure (structure.md)\n\n- New widget: `lib/src/widgets/mcal_day_view.dart` (~6,000-7,000 lines, mirrors month view structure)\n- Context objects: `lib/src/widgets/mcal_day_view_contexts.dart` (~600-800 lines)\n- Time utilities: `lib/src/utils/time_utils.dart` (~300-400 lines, pure functions for time↔offset conversion)\n- Exports: `lib/multi_calendar.dart` exports `MCalDayView` and all context/callback detail classes\n- Tests: `test/widgets/mcal_day_view_test.dart`, `test/utils/time_utils_test.dart`, integration tests\n- Theme extensions: `lib/src/styles/mcal_theme.dart` gains day view properties\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n\n**`MCalDragHandler`** (`lib/src/widgets/mcal_drag_handler.dart`, 915 lines)\n- Drag state machine: `startDrag()`, `updateDrag()`, `completeDrag()`, `cancelDrag()`\n- Resize state machine: `startResize()`, `updateResize()`, `completeResize()`, `cancelResize()`\n- Edge navigation: `handleEdgeProximity()` with self-repeating timer\n- Highlight cells: `_highlightedCells`, `_proposedStartDate`, `_proposedEndDate`, `_isProposedDropValid`\n- **Adaptation needed**: Add helper methods for time-based drag (vertical positioning instead of grid cells)\n\n**`MCalEventController`** (`lib/src/controllers/mcal_event_controller.dart`, 1,284 lines)\n- Event loading: `getEventsForRange()`, `addEvents()`, `removeEvents()`\n- Recurring event expansion: `_getExpandedOccurrences()` handles RRULE\n- Exception handling: `modifyOccurrence()`, `rescheduleOccurrence()`, `cancelOccurrence()`\n- Display date management: `setDisplayDate()`, listener pattern\n- **No changes needed**: Existing API fully supports day view\n\n**`MCalThemeData`** (`lib/src/styles/mcal_theme.dart`)\n- Theme InheritedWidget pattern: `MCalTheme.of(context)`\n- Fallback chain: widget ancestor → extension → `fromTheme()`\n- Existing properties: event tiles, drag feedback, borders, colors\n- **Extension needed**: Add day view-specific properties (time legend, gridlines, hour height, all-day section)\n\n**`MCalLocalizations`** (`lib/src/utils/mcal_localization.dart`)\n- String localization: `getLocalizedString(key, locale)`\n- RTL detection: `isRTL(locale)`\n- Existing strings: English and Spanish (es_MX)\n- **Extension needed**: Add day view-specific strings (time labels, today button, conversion announcements)\n\n**`daysBetween()`** (`lib/src/utils/date_utils.dart`)\n- DST-safe day delta calculation\n- **Reuse for**: Cross-day drag calculations, event type conversion date handling\n\n**Context Object Patterns** (`lib/src/widgets/mcal_month_view_contexts.dart`)\n- `MCalDayCellContext`, `MCalEventTileContext`, `MCalNavigatorContext`, etc.\n- Immutable data classes with all relevant context\n- **Follow pattern for**: `MCalTimeSlotContext`, `MCalTimeLabelContext`, `MCalTimedEventTileContext`, etc.\n\n**Callback Detail Patterns** (`lib/src/widgets/mcal_callback_details.dart`)\n- `MCalEventDroppedDetails`, `MCalEventResizedDetails`, `MCalDragWillAcceptDetails`\n- Immutable classes with full operation details\n- **Extend with**: `typeConversion` field to indicate all-day ↔ timed conversions\n\n### Integration Points\n\n- **MCalEventController**: Day view listens for event updates, calls `getEventsForRange()` for displayed date\n- **MCalDragHandler**: Day view creates handler instance, calls time-based drag methods, listens for state changes\n- **MCalTheme**: Day view reads theme via `MCalTheme.of(context)` with fallback chain\n- **Navigator pattern**: Reuses month view navigator builder pattern with adapted context\n- **PageView approach**: Consider single-page vs. PageView for day navigation (single page + setState preferred for simplicity)\n\n## Architecture\n\n```mermaid\ngraph TD\n    subgraph DayViewWidget [MCalDayView Widget]\n        State[_MCalDayViewState] --> Controller[MCalEventController]\n        State --> DragHandler[MCalDragHandler]\n        State --> ScrollController[ScrollController]\n        State --> Timer[Current Time Timer]\n    end\n    \n    subgraph LayoutStructure [Layout Structure]\n        Column1[Column] --> Navigator[Navigator Optional]\n        Column1 --> MainRow[Row TimeArea]\n        \n        MainRow --> TimeLegend[Time Legend]\n        MainRow --> EventsColumn[Events Column]\n        \n        EventsColumn --> DayHeader[Day Header]\n        EventsColumn --> AllDaySection[All-Day Section]\n        EventsColumn --> ScrollView[ScrollView Timed]\n        \n        ScrollView --> Stack5[Stack 5 Layers]\n        Stack5 --> L1[Layer 1 Gridlines]\n        Stack5 --> L2[Layer 2 Events]\n        Stack5 --> L3[Layer 3 TimeIndicator]\n        Stack5 --> L4[Layer 4 DropPreview]\n        Stack5 --> L5[Layer 5 DragGesture]\n    end\n    \n    subgraph EventLayout [Event Layout Engine]\n        OverlapDetect[Overlap Detection] --> ColumnAssign[Column Assignment]\n        ColumnAssign --> WidthCalc[Width Calculation]\n        WidthCalc --> Position[Positioned Widgets]\n    end\n    \n    subgraph DragOperations [Drag Operations]\n        DragMove[Drag to Move] --> TimeCalc[Time Slot Calc]\n        DragResize[Drag to Resize] --> TimeCalc\n        TimeCalc --> EdgeDetect[Edge Detection]\n        EdgeDetect --> DayNav[Day Navigation]\n        \n        TypeConv[Type Conversion] --> AllDayCheck{Drop in AllDay?}\n        AllDayCheck -->|Yes| ToAllDay[Convert to AllDay]\n        AllDayCheck -->|No| ToTimed[Convert to Timed]\n    end\n    \n    Controller --> DayViewWidget\n    DragHandler --> DragOperations\n    EventLayout --> L2\n```\n\n## Components and Interfaces\n\n### Component 1: MCalDayView Widget Structure\n\n**Purpose:** Top-level stateful widget providing the public API and managing overall state.\n\n**Public API:**\n```dart\nclass MCalDayView extends StatefulWidget {\n  const MCalDayView({\n    super.key,\n    required this.controller,\n    \n    // Time configuration\n    this.startHour = 0,\n    this.endHour = 23,\n    this.timeSlotDuration = const Duration(minutes: 15),\n    this.hourHeight,\n    \n    // Display\n    this.showNavigator = false,\n    this.showCurrentTimeIndicator = true,\n    this.showHalfHourLines = true,\n    this.dateFormat,\n    this.timeLabelFormat,\n    this.locale,\n    \n    // Scrolling\n    this.autoScrollToCurrentTime = true,\n    this.scrollPhysics,\n    this.scrollController,\n    \n    // All-day section\n    this.allDaySectionMaxRows = 3,\n    this.allDayToTimedDuration = const Duration(hours: 1),\n    \n    // Drag and drop\n    this.enableDragToMove = false,\n    this.enableDragToResize,  // null = platform auto-detect\n    this.dragEdgeNavigationEnabled = true,\n    this.dragLongPressDelay = const Duration(milliseconds: 200),\n    this.dragEdgeNavigationDelay = const Duration(milliseconds: 1200),\n    this.showDropTargetPreview = true,\n    this.showDropTargetOverlay = true,\n    \n    // Keyboard\n    this.enableKeyboardNavigation = true,\n    this.autoFocusOnEventTap = true,\n    \n    // Animations\n    this.enableAnimations,  // null = respect OS reduced motion\n    this.animationDuration = const Duration(milliseconds: 300),\n    this.animationCurve = Curves.easeInOut,\n    \n    // Boundaries\n    this.minDate,\n    this.maxDate,\n    \n    // Builders\n    this.dayHeaderBuilder,\n    this.timeLabelBuilder,\n    this.gridlineBuilder,\n    this.allDayEventTileBuilder,\n    this.timedEventTileBuilder,\n    this.currentTimeIndicatorBuilder,\n    this.navigatorBuilder,\n    this.dayLayoutBuilder,\n    this.draggedTileBuilder,\n    this.dropTargetTileBuilder,\n    this.timeResizeHandleBuilder,\n    this.loadingBuilder,\n    this.errorBuilder,\n    \n    // Callbacks\n    this.onDayHeaderTap,\n    this.onDayHeaderLongPress,\n    this.onTimeLabelTap,\n    this.onTimeSlotTap,\n    this.onTimeSlotLongPress,\n    this.onEventTap,\n    this.onEventLongPress,\n    this.onHoverEvent,\n    this.onHoverTimeSlot,\n    this.onOverflowTap,\n    this.onOverflowLongPress,\n    this.onDragWillAccept,\n    this.onEventDropped,\n    this.onResizeWillAccept,\n    this.onEventResized,\n    this.onDisplayDateChanged,\n    this.onScrollChanged,\n    \n    // Semantic label\n    this.semanticsLabel,\n  });\n  \n  // Fields...\n}\n```\n\n**Dependencies:** `MCalEventController`, optional `MCalDragHandler` (lazy-created when drag enabled)\n\n**Reuses:** Month view parameter patterns, callback signatures, builder patterns\n\n### Component 2: Time Calculation Utilities\n\n**Purpose:** Pure functions for converting between time values and pixel offsets.\n\n**Location:** `lib/src/utils/time_utils.dart`\n\n**Functions:**\n```dart\n/// Converts a time to a vertical offset in pixels.\n/// \n/// Returns the distance from the top of the time range to the given time.\ndouble timeToOffset({\n  required DateTime time,\n  required int startHour,\n  required double hourHeight,\n}) {\n  final minutesFromStart = (time.hour - startHour) * 60 + time.minute;\n  return (minutesFromStart / 60.0) * hourHeight;\n}\n\n/// Converts a vertical offset to a time, with optional slot snapping.\n///\n/// Returns a DateTime on the given date with time calculated from offset.\nDateTime offsetToTime({\n  required double offset,\n  required DateTime date,\n  required int startHour,\n  required double hourHeight,\n  required Duration timeSlotDuration,\n}) {\n  final minutesFromStart = (offset / hourHeight) * 60;\n  final snappedMinutes = (minutesFromStart / timeSlotDuration.inMinutes).round() \n    * timeSlotDuration.inMinutes;\n  \n  // DST-safe: construct DateTime with hour/minute\n  final totalMinutes = startHour * 60 + snappedMinutes;\n  final hour = totalMinutes ~/ 60;\n  final minute = totalMinutes % 60;\n  \n  return DateTime(date.year, date.month, date.day, hour, minute);\n}\n\n/// Snaps a time to the nearest time slot boundary.\nDateTime snapToTimeSlot({\n  required DateTime time,\n  required Duration timeSlotDuration,\n}) {\n  final totalMinutes = time.hour * 60 + time.minute;\n  final snappedMinutes = (totalMinutes / timeSlotDuration.inMinutes).round() \n    * timeSlotDuration.inMinutes;\n  \n  final hour = snappedMinutes ~/ 60;\n  final minute = snappedMinutes % 60;\n  \n  return DateTime(time.year, time.month, time.day, hour, minute);\n}\n\n/// Calculates the height in pixels for a duration.\ndouble durationToHeight({\n  required Duration duration,\n  required double hourHeight,\n}) {\n  return (duration.inMinutes / 60.0) * hourHeight;\n}\n```\n\n**Dependencies:** None (pure functions)\n\n**Testing:** Extensive unit tests for DST boundaries, time slot snapping, edge cases\n\n### Component 3: Overlap Detection Algorithm\n\n**Purpose:** Detects overlapping events and assigns them to columns for side-by-side layout.\n\n**Location:** `lib/src/utils/overlap_detection.dart` (new file) or inline in `mcal_day_view.dart`\n\n**Algorithm:**\n```dart\nclass MCalOverlapGroup {\n  final List<MCalCalendarEvent> events;\n  final List<int> columnAssignments;  // index matches events\n  final int totalColumns;\n  \n  const MCalOverlapGroup({\n    required this.events,\n    required this.columnAssignments,\n    required this.totalColumns,\n  });\n}\n\n/// Detects overlapping events and assigns columns.\nMCalOverlapGroup detectOverlapsAndAssignColumns(\n  List<MCalCalendarEvent> events,\n) {\n  if (events.isEmpty) {\n    return const MCalOverlapGroup(\n      events: [],\n      columnAssignments: [],\n      totalColumns: 0,\n    );\n  }\n  \n  // Sort by start time, then by duration (longest first)\n  final sorted = List<MCalCalendarEvent>.from(events)..sort((a, b) {\n    final timeCompare = a.start.compareTo(b.start);\n    if (timeCompare != 0) return timeCompare;\n    // Longer events first\n    return b.end.difference(b.start).compareTo(a.end.difference(a.start));\n  });\n  \n  final columnAssignments = <int>[];\n  final columns = <List<MCalCalendarEvent>>[];\n  \n  for (final event in sorted) {\n    // Find first available column\n    int assignedColumn = -1;\n    for (int col = 0; col < columns.length; col++) {\n      final colEvents = columns[col];\n      // Check if event overlaps with any event in this column\n      bool hasOverlap = false;\n      for (final colEvent in colEvents) {\n        if (_eventsOverlap(event, colEvent)) {\n          hasOverlap = true;\n          break;\n        }\n      }\n      if (!hasOverlap) {\n        assignedColumn = col;\n        break;\n      }\n    }\n    \n    // If no available column, create new one\n    if (assignedColumn == -1) {\n      assignedColumn = columns.length;\n      columns.add([]);\n    }\n    \n    columns[assignedColumn].add(event);\n    columnAssignments.add(assignedColumn);\n  }\n  \n  return MCalOverlapGroup(\n    events: sorted,\n    columnAssignments: columnAssignments,\n    totalColumns: columns.length,\n  );\n}\n\nbool _eventsOverlap(MCalCalendarEvent a, MCalCalendarEvent b) {\n  return a.start.isBefore(b.end) && b.start.isBefore(a.end);\n}\n```\n\n**Complexity:** O(n²) in worst case (all events overlap), O(n·k) average where k is number of columns (typically 2-4)\n\n**Reuses:** Event comparison logic\n\n### Component 4: Time Legend Column\n\n**Purpose:** Renders hour labels along the left (LTR) or right (RTL) edge.\n\n**Widget:** `_TimeLegendColumn` (private StatelessWidget)\n\n**Design:**\n```dart\nclass _TimeLegendColumn extends StatelessWidget {\n  final int startHour;\n  final int endHour;\n  final double hourHeight;\n  final String? timeLabelFormat;\n  final Widget Function(BuildContext, MCalTimeLabelContext)? timeLabelBuilder;\n  final MCalThemeData theme;\n  final Locale locale;\n  final VoidCallback? onTimeLabelTap;\n  \n  @override\n  Widget build(BuildContext context) {\n    final totalHours = endHour - startHour + 1;\n    final columnHeight = hourHeight * totalHours;\n    \n    return Container(\n      width: theme.timeLegendWidth ?? 60.0,\n      height: columnHeight,\n      color: theme.timeLegendBackgroundColor,\n      child: Stack(\n        children: [\n          for (int hour = startHour; hour <= endHour; hour++)\n            Positioned(\n              top: (hour - startHour) * hourHeight,\n              left: 0,\n              right: 0,\n              child: _buildHourLabel(hour),\n            ),\n        ],\n      ),\n    );\n  }\n  \n  Widget _buildHourLabel(int hour) {\n    final time = DateTime(2000, 1, 1, hour, 0);  // Date irrelevant\n    final context = MCalTimeLabelContext(\n      hour: hour,\n      time: time,\n      locale: locale,\n    );\n    \n    if (timeLabelBuilder != null) {\n      return timeLabelBuilder!(context, context);\n    }\n    \n    // Default: format using locale\n    final format = timeLabelFormat ?? (locale.languageCode == 'en' ? 'h a' : 'HH:mm');\n    final label = DateFormat(format, locale.toString()).format(time);\n    \n    return GestureDetector(\n      onTap: onTimeLabelTap,\n      child: Center(\n        child: Text(\n          label,\n          style: theme.timeLegendTextStyle,\n        ),\n      ),\n    );\n  }\n}\n```\n\n**Dependencies:** intl `DateFormat`, theme\n\n**Reuses:** Locale detection pattern from month view\n\n### Component 5: Gridlines Layer\n\n**Purpose:** Renders horizontal lines at hour and half-hour intervals.\n\n**Widget:** `_GridlinesLayer` (private StatelessWidget in Stack)\n\n**Design:**\n```dart\nclass _GridlinesLayer extends StatelessWidget {\n  final int startHour;\n  final int endHour;\n  final double hourHeight;\n  final bool showHalfHourLines;\n  final MCalThemeData theme;\n  final Widget Function(BuildContext, MCalGridlineContext)? gridlineBuilder;\n  \n  @override\n  Widget build(BuildContext context) {\n    final totalHours = endHour - startHour + 1;\n    final height = hourHeight * totalHours;\n    \n    return SizedBox(\n      height: height,\n      child: Stack(\n        children: [\n          // Hour gridlines\n          for (int hour = startHour; hour <= endHour; hour++)\n            _buildGridline(\n              offset: (hour - startHour) * hourHeight,\n              isHalfHour: false,\n              hour: hour,\n            ),\n          // Half-hour gridlines\n          if (showHalfHourLines)\n            for (int hour = startHour; hour < endHour; hour++)\n              _buildGridline(\n                offset: (hour - startHour) * hourHeight + hourHeight / 2,\n                isHalfHour: true,\n                hour: hour,\n              ),\n        ],\n      ),\n    );\n  }\n  \n  Widget _buildGridline({\n    required double offset,\n    required bool isHalfHour,\n    required int hour,\n  }) {\n    final context = MCalGridlineContext(\n      hour: hour,\n      isHalfHour: isHalfHour,\n    );\n    \n    if (gridlineBuilder != null) {\n      return Positioned(\n        top: offset,\n        left: 0,\n        right: 0,\n        child: gridlineBuilder!(this.context, context),\n      );\n    }\n    \n    // Default gridline\n    final color = isHalfHour \n      ? (theme.halfHourGridlineColor ?? Colors.grey.withValues(alpha: 0.1))\n      : (theme.hourGridlineColor ?? Colors.grey.withValues(alpha: 0.2));\n      \n    return Positioned(\n      top: offset,\n      left: 0,\n      right: 0,\n      child: Container(\n        height: 1,\n        color: color,\n      ),\n    );\n  }\n}\n```\n\n**Dependencies:** Theme\n\n**Reuses:** `Positioned` layout pattern from month view week rows\n\n### Component 6: All-Day Events Section\n\n**Purpose:** Displays all-day events horizontally with overflow handling, drag source, and resize handles.\n\n**Widget:** `_AllDayEventsSection` (private StatefulWidget)\n\n**Design:**\n```dart\nclass _AllDayEventsSection extends StatefulWidget {\n  final List<MCalCalendarEvent> allDayEvents;\n  final int maxRows;\n  final MCalThemeData theme;\n  final Widget Function(BuildContext, MCalEventTileContext, Widget)? tileBuilder;\n  final bool enableDragToMove;\n  final bool enableDragToResize;\n  final Function(MCalCalendarEvent)? onEventTap;\n  final Function(MCalCalendarEvent)? onEventLongPress;\n  final VoidCallback? onOverflowTap;\n  \n  @override\n  State<_AllDayEventsSection> createState() => _AllDayEventsSectionState();\n}\n\nclass _AllDayEventsSectionState extends State<_AllDayEventsSection> {\n  @override\n  Widget build(BuildContext context) {\n    final visibleEvents = widget.allDayEvents.take(widget.maxRows * 2).toList();\n    final hasOverflow = widget.allDayEvents.length > visibleEvents.length;\n    \n    return Container(\n      constraints: BoxConstraints(\n        maxHeight: widget.theme.allDaySectionHeight \n          ?? (widget.maxRows * (theme.eventTileHeight + 4.0)),\n      ),\n      child: Column(\n        mainAxisSize: MainAxisSize.min,\n        children: [\n          Wrap(\n            children: [\n              for (final event in visibleEvents)\n                _buildAllDayTile(event),\n            ],\n          ),\n          if (hasOverflow)\n            _buildOverflowIndicator(widget.allDayEvents.length - visibleEvents.length),\n        ],\n      ),\n    );\n  }\n  \n  Widget _buildAllDayTile(MCalCalendarEvent event) {\n    final tileContext = MCalEventTileContext(\n      event: event,\n      displayDate: widget.displayDate,\n      isAllDay: true,\n      // ... other context fields\n    );\n    \n    Widget tile = Container(\n      height: theme.eventTileHeight,\n      padding: theme.eventTilePadding,\n      decoration: BoxDecoration(\n        color: event.color ?? theme.allDayEventBackgroundColor,\n        borderRadius: BorderRadius.circular(theme.eventTileCornerRadius ?? 4.0),\n      ),\n      child: Text(event.title, style: theme.allDayEventTextStyle),\n    );\n    \n    if (widget.tileBuilder != null) {\n      tile = widget.tileBuilder!(context, tileContext, tile);\n    }\n    \n    // Wrap in draggable if enabled\n    if (widget.enableDragToMove) {\n      tile = MCalDraggableEventTile(\n        event: event,\n        child: tile,\n        // ... drag configuration\n      );\n    }\n    \n    // Add resize handles if enabled\n    if (widget.enableDragToResize && _shouldShowResizeHandles(event)) {\n      tile = _wrapWithResizeHandles(tile, event, tileContext);\n    }\n    \n    return GestureDetector(\n      onTap: () => widget.onEventTap?.call(event),\n      onLongPress: () => widget.onEventLongPress?.call(event),\n      child: tile,\n    );\n  }\n}\n```\n\n**Dependencies:** `MCalDraggableEventTile`, theme\n\n**Reuses:** Month view's multi-day tile rendering pattern, drag infrastructure\n\n### Component 7: Timed Events Layer with Overlap Layout\n\n**Purpose:** Renders timed events with automatic column layout for overlaps.\n\n**Widget:** `_TimedEventsLayer` (private StatelessWidget in Stack)\n\n**Design:**\n```dart\nclass _TimedEventsLayer extends StatelessWidget {\n  final List<MCalCalendarEvent> timedEvents;\n  final DateTime displayDate;\n  final int startHour;\n  final int endHour;\n  final double hourHeight;\n  final Duration timeSlotDuration;\n  final double areaWidth;\n  final MCalThemeData theme;\n  final Widget Function(BuildContext, MCalTimedEventTileContext, Widget)? tileBuilder;\n  final MCalDayLayoutBuilder? dayLayoutBuilder;\n  final bool enableDragToMove;\n  final bool enableDragToResize;\n  \n  @override\n  Widget build(BuildContext context) {\n    final totalHeight = hourHeight * (endHour - startHour + 1);\n    \n    // Use custom layout builder if provided\n    if (dayLayoutBuilder != null) {\n      return SizedBox(\n        height: totalHeight,\n        child: dayLayoutBuilder!(context, MCalDayLayoutContext(\n          events: timedEvents,\n          displayDate: displayDate,\n          startHour: startHour,\n          endHour: endHour,\n          hourHeight: hourHeight,\n          areaWidth: areaWidth,\n        )),\n      );\n    }\n    \n    // Default: overlap detection + column layout\n    final overlapGroup = detectOverlapsAndAssignColumns(timedEvents);\n    \n    return SizedBox(\n      height: totalHeight,\n      child: Stack(\n        children: [\n          for (int i = 0; i < overlapGroup.events.length; i++)\n            _buildPositionedEvent(\n              overlapGroup.events[i],\n              overlapGroup.columnAssignments[i],\n              overlapGroup.totalColumns,\n            ),\n        ],\n      ),\n    );\n  }\n  \n  Widget _buildPositionedEvent(\n    MCalCalendarEvent event,\n    int columnIndex,\n    int totalColumns,\n  ) {\n    // Calculate position and size\n    final topOffset = timeToOffset(\n      time: event.start,\n      startHour: startHour,\n      hourHeight: hourHeight,\n    );\n    \n    final height = durationToHeight(\n      duration: event.end.difference(event.start),\n      hourHeight: hourHeight,\n    ).clamp(theme.timedEventMinHeight ?? 20.0, double.infinity);\n    \n    final columnWidth = areaWidth / totalColumns;\n    final leftOffset = columnIndex * columnWidth;\n    \n    final tileContext = MCalTimedEventTileContext(\n      event: event,\n      displayDate: displayDate,\n      columnIndex: columnIndex,\n      totalColumns: totalColumns,\n      startTime: event.start,\n      endTime: event.end,\n    );\n    \n    Widget tile = _buildEventTile(event, tileContext);\n    \n    // Add resize handles if enabled\n    if (enableDragToResize) {\n      tile = _wrapWithResizeHandles(tile, event, tileContext);\n    }\n    \n    return Positioned(\n      top: topOffset,\n      left: leftOffset,\n      width: columnWidth,\n      height: height,\n      child: tile,\n    );\n  }\n}\n```\n\n**Dependencies:** Overlap detection algorithm, time utilities, `MCalDraggableEventTile`\n\n**Reuses:** Month view event tile rendering patterns, drag infrastructure\n\n### Component 8: Current Time Indicator\n\n**Purpose:** Displays horizontal line at current time with automatic updates.\n\n**Widget:** `_CurrentTimeIndicator` (private StatefulWidget)\n\n**Design:**\n```dart\nclass _CurrentTimeIndicator extends StatefulWidget {\n  final int startHour;\n  final double hourHeight;\n  final bool isRTL;\n  final MCalThemeData theme;\n  final Widget Function(BuildContext, MCalCurrentTimeContext)? builder;\n  \n  @override\n  State<_CurrentTimeIndicator> createState() => _CurrentTimeIndicatorState();\n}\n\nclass _CurrentTimeIndicatorState extends State<_CurrentTimeIndicator> {\n  Timer? _timer;\n  DateTime _currentTime = DateTime.now();\n  \n  @override\n  void initState() {\n    super.initState();\n    _startTimer();\n  }\n  \n  void _startTimer() {\n    // Update every minute\n    _timer = Timer.periodic(const Duration(minutes: 1), (_) {\n      if (mounted) {\n        setState(() {\n          _currentTime = DateTime.now();\n        });\n      }\n    });\n  }\n  \n  @override\n  void dispose() {\n    _timer?.cancel();\n    super.dispose();\n  }\n  \n  @override\n  Widget build(BuildContext context) {\n    final offset = timeToOffset(\n      time: _currentTime,\n      startHour: widget.startHour,\n      hourHeight: widget.hourHeight,\n    );\n    \n    final indicatorContext = MCalCurrentTimeContext(\n      currentTime: _currentTime,\n      offset: offset,\n      isRTL: widget.isRTL,\n    );\n    \n    if (widget.builder != null) {\n      return Positioned(\n        top: offset,\n        left: 0,\n        right: 0,\n        child: widget.builder!(context, indicatorContext),\n      );\n    }\n    \n    // Default indicator\n    return Positioned(\n      top: offset,\n      left: 0,\n      right: 0,\n      child: Row(\n        children: [\n          if (!widget.isRTL) _buildDot(),\n          Expanded(\n            child: Container(\n              height: widget.theme.currentTimeIndicatorWidth ?? 2.0,\n              color: widget.theme.currentTimeIndicatorColor ?? Colors.red,\n            ),\n          ),\n          if (widget.isRTL) _buildDot(),\n        ],\n      ),\n    );\n  }\n  \n  Widget _buildDot() {\n    return Container(\n      width: (widget.theme.currentTimeIndicatorDotRadius ?? 6.0) * 2,\n      height: (widget.theme.currentTimeIndicatorDotRadius ?? 6.0) * 2,\n      decoration: BoxDecoration(\n        shape: BoxShape.circle,\n        color: widget.theme.currentTimeIndicatorColor ?? Colors.red,\n      ),\n    );\n  }\n}\n```\n\n**Dependencies:** Theme, time utilities, `Timer`\n\n**Reuses:** `Positioned` layout, theme pattern\n\n### Component 9: Drag-to-Move Integration\n\n**Purpose:** Handles vertical drag within day and horizontal edge navigation for cross-day moves.\n\n**Location:** Methods in `_MCalDayViewState`\n\n**Design:**\n```dart\n// In _MCalDayViewState\n\nMCalDragHandler? _dragHandler;\nMCalDragHandler get _ensureDragHandler {\n  return _dragHandler ??= MCalDragHandler();\n}\n\nvoid _handleDragStarted(MCalCalendarEvent event, Offset localPosition) {\n  _dragHandler?.startDrag(event, event.start);\n  setState(() {\n    _isDragActive = true;\n  });\n}\n\nvoid _handleDragUpdate(DragUpdateDetails details) {\n  if (_dragHandler == null || !_dragHandler!.isDragging) return;\n  \n  final RenderBox? renderBox = _timedEventsAreaKey.currentContext?.findRenderObject() as RenderBox?;\n  if (renderBox == null) return;\n  \n  final localPosition = renderBox.globalToLocal(details.globalPosition);\n  \n  // Check for section boundary crossing (all-day ↔ timed conversion)\n  final isInAllDaySection = localPosition.dy < 0;  // Negative = above timed area\n  \n  if (isInAllDaySection && !_dragHandler!.draggedEvent!.isAllDay) {\n    // Converting timed → all-day\n    _handleTimedToAllDayConversion(localPosition);\n  } else if (!isInAllDaySection && _dragHandler!.draggedEvent!.isAllDay) {\n    // Converting all-day → timed\n    _handleAllDayToTimedConversion(localPosition);\n  } else {\n    // Same type: calculate new time/date\n    _handleSameTypeMove(localPosition);\n  }\n  \n  // Check horizontal edge proximity for day navigation\n  if (widget.dragEdgeNavigationEnabled) {\n    _checkHorizontalEdgeProximity(localPosition.dx);\n  }\n}\n\nvoid _handleTimedToAllDayConversion(Offset localPosition) {\n  // Use current displayed date (accounting for edge navigation)\n  final proposedStart = DateTime(_displayDate.year, _displayDate.month, _displayDate.day, 0, 0);\n  final proposedEnd = DateTime(_displayDate.year, _displayDate.month, _displayDate.day, 0, 0);\n  \n  _dragHandler!.updateProposedDropRange(\n    proposedStart: proposedStart,\n    proposedEnd: proposedEnd,\n    isValid: _validateDrop(proposedStart, proposedEnd, isAllDay: true),\n  );\n}\n\nvoid _handleAllDayToTimedConversion(Offset localPosition) {\n  // Calculate time from Y position\n  final proposedStartTime = offsetToTime(\n    offset: localPosition.dy,\n    date: _displayDate,\n    startHour: widget.startHour,\n    hourHeight: _cachedHourHeight,\n    timeSlotDuration: widget.timeSlotDuration,\n  );\n  \n  final proposedEndTime = proposedStartTime.add(widget.allDayToTimedDuration);\n  \n  _dragHandler!.updateProposedDropRange(\n    proposedStart: proposedStartTime,\n    proposedEnd: proposedEndTime,\n    isValid: _validateDrop(proposedStartTime, proposedEndTime, isAllDay: false),\n  );\n}\n\nvoid _handleSameTypeMove(Offset localPosition) {\n  final originalEvent = _dragHandler!.draggedEvent!;\n  final duration = originalEvent.end.difference(originalEvent.start);\n  \n  // Calculate new start time from Y position\n  final proposedStart = offsetToTime(\n    offset: localPosition.dy,\n    date: _displayDate,\n    startHour: widget.startHour,\n    hourHeight: _cachedHourHeight,\n    timeSlotDuration: widget.timeSlotDuration,\n  );\n  \n  final proposedEnd = proposedStart.add(duration);\n  \n  _dragHandler!.updateProposedDropRange(\n    proposedStart: proposedStart,\n    proposedEnd: proposedEnd,\n    isValid: _validateDrop(proposedStart, proposedEnd, isAllDay: originalEvent.isAllDay),\n  );\n}\n\nvoid _checkHorizontalEdgeProximity(double localX) {\n  final edgeThreshold = _cachedAreaWidth * 0.1;\n  final nearLeftEdge = localX < edgeThreshold;\n  final nearRightEdge = localX > (_cachedAreaWidth - edgeThreshold);\n  \n  if (nearLeftEdge) {\n    _dragHandler!.handleEdgeProximity(\n      isNearEdge: true,\n      isLeftEdge: true,\n      navigateCallback: _navigateToPreviousDay,\n      delay: widget.dragEdgeNavigationDelay,\n    );\n  } else if (nearRightEdge) {\n    _dragHandler!.handleEdgeProximity(\n      isNearEdge: true,\n      isLeftEdge: false,\n      navigateCallback: _navigateToNextDay,\n      delay: widget.dragEdgeNavigationDelay,\n    );\n  } else {\n    _dragHandler!.handleEdgeProximity(\n      isNearEdge: false,\n      isLeftEdge: false,\n      navigateCallback: () {},\n    );\n  }\n}\n\nvoid _handleDrop() {\n  final dragHandler = _dragHandler;\n  if (dragHandler == null || !dragHandler.isDragging) return;\n  \n  final proposedStart = dragHandler.proposedStartDate;\n  final proposedEnd = dragHandler.proposedEndDate;\n  \n  if (proposedStart == null || proposedEnd == null || !dragHandler.isProposedDropValid) {\n    dragHandler.cancelDrag();\n    setState(() => _isDragActive = false);\n    return;\n  }\n  \n  final originalEvent = dragHandler.draggedEvent!;\n  final typeChanged = originalEvent.isAllDay != _isAllDayArea(proposedStart, proposedEnd);\n  \n  // Build updated event\n  final updatedEvent = originalEvent.copyWith(\n    start: proposedStart,\n    end: proposedEnd,\n    isAllDay: _isAllDayArea(proposedStart, proposedEnd),\n  );\n  \n  // Build details\n  final details = MCalEventDroppedDetails(\n    event: originalEvent,\n    newStart: proposedStart,\n    newEnd: proposedEnd,\n    oldStart: originalEvent.start,\n    oldEnd: originalEvent.end,\n    isRecurring: originalEvent.recurrenceRule != null,\n    seriesId: originalEvent.seriesId,\n    typeConversion: typeChanged ? (originalEvent.isAllDay ? 'allDayToTimed' : 'timedToAllDay') : null,\n  );\n  \n  // Call callback\n  final accepted = widget.onEventDropped?.call(context, details) ?? true;\n  \n  if (accepted) {\n    if (originalEvent.occurrenceId != null) {\n      // Recurring: create modified exception\n      widget.controller.modifyOccurrence(\n        originalEvent.seriesId!,\n        DateTime.parse(originalEvent.occurrenceId!),\n        updatedEvent,\n      );\n    } else {\n      // Non-recurring: update event\n      widget.controller.addEvents([updatedEvent]);\n    }\n  }\n  \n  dragHandler.completeDrag();\n  setState(() => _isDragActive = false);\n}\n```\n\n**Dependencies:** `MCalDragHandler`, time utilities, controller\n\n**Reuses:** Month view `_handleDrop` flow, exception handling pattern\n\n### Component 10: Resize Integration with Time-Based Edges\n\n**Purpose:** Handles top/bottom edge resize for timed events and left/right edge resize for all-day events.\n\n**Location:** Methods in `_MCalDayViewState`\n\n**Design:**\n```dart\n// Resize handle widget\nclass _TimeResizeHandle extends StatelessWidget {\n  final MCalResizeEdge edge;  // start (top) or end (bottom)\n  final MCalCalendarEvent event;\n  final bool isAllDayEvent;\n  final double handleHeight;  // 8.0 default for timed, full width for all-day\n  final VoidCallback onResizeStart;\n  final ValueChanged<Offset> onResizeUpdate;\n  final VoidCallback onResizeEnd;\n  final VoidCallback onResizeCancel;\n  final Widget Function(BuildContext, MCalResizeHandleContext)? visualBuilder;\n  \n  @override\n  Widget build(BuildContext context) {\n    final handleContext = MCalResizeHandleContext(\n      edge: edge,\n      event: event,\n      isDropTargetPreview: false,\n    );\n    \n    Widget visual;\n    if (visualBuilder != null) {\n      visual = visualBuilder!(context, handleContext);\n    } else {\n      // Default: semi-transparent bar\n      visual = Container(\n        height: isAllDayEvent ? 2.0 : handleHeight,\n        width: isAllDayEvent ? handleHeight : double.infinity,\n        color: Colors.white.withValues(alpha: 0.5),\n      );\n    }\n    \n    return Positioned(\n      top: edge == MCalResizeEdge.start ? 0 : null,\n      bottom: edge == MCalResizeEdge.end ? 0 : null,\n      left: 0,\n      right: 0,\n      child: MouseRegion(\n        cursor: isAllDayEvent \n          ? SystemMouseCursors.resizeColumn \n          : SystemMouseCursors.resizeUpDown,\n        child: GestureDetector(\n          onPanStart: (_) => onResizeStart(),\n          onPanUpdate: (details) => onResizeUpdate(details.localPosition),\n          onPanEnd: (_) => onResizeEnd(),\n          onPanCancel: () => onResizeCancel(),\n          child: visual,\n        ),\n      ),\n    );\n  }\n}\n\n// In _MCalDayViewState\n\nvoid _handleResizeStart(MCalCalendarEvent event, MCalResizeEdge edge) {\n  _dragHandler?.startResize(event, edge);\n  setState(() => _isResizeActive = true);\n}\n\nvoid _handleResizeUpdate(Offset localPosition, MCalResizeEdge edge, bool isAllDay) {\n  if (_dragHandler == null || !_dragHandler!.isResizing) return;\n  \n  final originalEvent = _dragHandler!.resizingEvent!;\n  \n  if (isAllDay) {\n    // All-day: horizontal resize changes dates\n    _handleAllDayResize(localPosition, edge, originalEvent);\n  } else {\n    // Timed: vertical resize changes times\n    _handleTimedResize(localPosition, edge, originalEvent);\n  }\n  \n  // Check horizontal edge proximity for day navigation (both event types)\n  if (widget.dragEdgeNavigationEnabled) {\n    _checkHorizontalEdgeProximityForResize(localPosition.dx);\n  }\n}\n\nvoid _handleTimedResize(Offset localPosition, MCalResizeEdge edge, MCalCalendarEvent event) {\n  DateTime proposedStart = event.start;\n  DateTime proposedEnd = event.end;\n  \n  if (edge == MCalResizeEdge.start) {\n    // Top edge: change start time\n    proposedStart = offsetToTime(\n      offset: localPosition.dy,\n      date: _displayDate,\n      startHour: widget.startHour,\n      hourHeight: _cachedHourHeight,\n      timeSlotDuration: widget.timeSlotDuration,\n    );\n    // Enforce minimum duration\n    final minimumEnd = proposedStart.add(widget.timeSlotDuration);\n    if (proposedEnd.isBefore(minimumEnd)) {\n      proposedStart = proposedEnd.subtract(widget.timeSlotDuration);\n    }\n  } else {\n    // Bottom edge: change end time\n    proposedEnd = offsetToTime(\n      offset: localPosition.dy,\n      date: _displayDate,\n      startHour: widget.startHour,\n      hourHeight: _cachedHourHeight,\n      timeSlotDuration: widget.timeSlotDuration,\n    );\n    // Enforce minimum duration\n    final minimumEnd = proposedStart.add(widget.timeSlotDuration);\n    if (proposedEnd.isBefore(minimumEnd)) {\n      proposedEnd = minimumEnd;\n    }\n  }\n  \n  final isValid = _validateResize(event, proposedStart, proposedEnd, edge);\n  \n  _dragHandler!.updateResize(\n    proposedStart: proposedStart,\n    proposedEnd: proposedEnd,\n    isValid: isValid,\n    cells: [], // Time-based highlight, not cells\n  );\n}\n\nvoid _handleAllDayResize(Offset localPosition, MCalResizeEdge edge, MCalCalendarEvent event) {\n  // Similar to month view: horizontal position determines date delta\n  final dayDelta = (localPosition.dx / _cachedDayWidth).round();\n  \n  DateTime proposedStart = event.start;\n  DateTime proposedEnd = event.end;\n  \n  if (edge == MCalResizeEdge.start) {\n    proposedStart = DateTime(\n      _displayDate.year,\n      _displayDate.month,\n      _displayDate.day + dayDelta,\n    );\n    // Enforce minimum 1 day\n    if (!proposedStart.isBefore(proposedEnd)) {\n      proposedStart = DateTime(proposedEnd.year, proposedEnd.month, proposedEnd.day - 1);\n    }\n  } else {\n    proposedEnd = DateTime(\n      _displayDate.year,\n      _displayDate.month,\n      _displayDate.day + dayDelta,\n    );\n    // Enforce minimum 1 day\n    if (!proposedEnd.isAfter(proposedStart)) {\n      proposedEnd = DateTime(proposedStart.year, proposedStart.month, proposedStart.day + 1);\n    }\n  }\n  \n  final isValid = _validateResize(event, proposedStart, proposedEnd, edge);\n  \n  _dragHandler!.updateResize(\n    proposedStart: proposedStart,\n    proposedEnd: proposedEnd,\n    isValid: isValid,\n    cells: _buildHighlightCells(proposedStart, proposedEnd),\n  );\n}\n```\n\n**Dependencies:** `MCalDragHandler`, time utilities\n\n**Reuses:** Month view edge navigation pattern, `handleEdgeProximity()` method\n\n### Component 11: Event Type Conversion Logic\n\n**Purpose:** Handles all-day ↔ timed conversions during drag operations.\n\n**Design:**\n```dart\n// In _MCalDayViewState\n\nbool _isDropInAllDaySection(Offset localPosition) {\n  // Check if Y position is in all-day section (negative offset from timed area)\n  return localPosition.dy < 0;\n}\n\n(DateTime start, DateTime end, bool isAllDay) _calculateConvertedEventTimes({\n  required MCalCalendarEvent originalEvent,\n  required Offset dropPosition,\n  required DateTime dropDate,\n}) {\n  final wasAllDay = originalEvent.isAllDay;\n  final isAllDayDrop = _isDropInAllDaySection(dropPosition);\n  \n  if (wasAllDay && !isAllDayDrop) {\n    // All-day → Timed conversion\n    final startTime = offsetToTime(\n      offset: dropPosition.dy,\n      date: dropDate,\n      startHour: widget.startHour,\n      hourHeight: _cachedHourHeight,\n      timeSlotDuration: widget.timeSlotDuration,\n    );\n    \n    final endTime = startTime.add(widget.allDayToTimedDuration);\n    \n    // Clamp end time if it exceeds endHour\n    final maxEndTime = DateTime(dropDate.year, dropDate.month, dropDate.day, widget.endHour, 0);\n    final clampedEnd = endTime.isAfter(maxEndTime) ? maxEndTime : endTime;\n    \n    return (startTime, clampedEnd, false);\n    \n  } else if (!wasAllDay && isAllDayDrop) {\n    // Timed → All-day conversion\n    final allDayStart = DateTime(dropDate.year, dropDate.month, dropDate.day, 0, 0);\n    final allDayEnd = DateTime(dropDate.year, dropDate.month, dropDate.day, 0, 0);\n    \n    return (allDayStart, allDayEnd, true);\n    \n  } else {\n    // No conversion: same type move\n    final duration = originalEvent.end.difference(originalEvent.start);\n    final newStart = offsetToTime(\n      offset: dropPosition.dy,\n      date: dropDate,\n      startHour: widget.startHour,\n      hourHeight: _cachedHourHeight,\n      timeSlotDuration: widget.timeSlotDuration,\n    );\n    final newEnd = newStart.add(duration);\n    \n    return (newStart, newEnd, originalEvent.isAllDay);\n  }\n}\n```\n\n**Dependencies:** Time utilities\n\n**Reuses:** Pattern similar to month view's cross-section drag\n\n### Component 12: Keyboard Navigation for Day View\n\n**Purpose:** Keyboard-based event selection, move mode, and resize mode.\n\n**Location:** `_handleKeyEvent` method in `_MCalDayViewState`\n\n**Design:**\n```dart\nKeyEventResult _handleKeyEvent(FocusNode node, KeyEvent event) {\n  if (event is! KeyDownEvent) return KeyEventResult.ignored;\n  \n  // Handle based on current mode\n  if (_isKeyboardResizeMode) {\n    return _handleKeyboardResize(event.logicalKey);\n  } else if (_isKeyboardMoveMode) {\n    return _handleKeyboardMove(event.logicalKey);\n  } else {\n    return _handleKeyboardNavigation(event.logicalKey);\n  }\n}\n\nKeyEventResult _handleKeyboardNavigation(LogicalKeyboardKey key) {\n  if (key == LogicalKeyboardKey.arrowLeft) {\n    _navigateToPreviousDay();\n    return KeyEventResult.handled;\n  } else if (key == LogicalKeyboardKey.arrowRight) {\n    _navigateToNextDay();\n    return KeyEventResult.handled;\n  } else if (key == LogicalKeyboardKey.arrowUp) {\n    _focusPreviousEvent();\n    return KeyEventResult.handled;\n  } else if (key == LogicalKeyboardKey.arrowDown) {\n    _focusNextEvent();\n    return KeyEventResult.handled;\n  } else if (key == LogicalKeyboardKey.enter || key == LogicalKeyboardKey.space) {\n    if (_focusedEvent != null) {\n      _enterKeyboardMoveMode(_focusedEvent!);\n      return KeyEventResult.handled;\n    }\n  } else if (key == LogicalKeyboardKey.home) {\n    _navigateToToday();\n    return KeyEventResult.handled;\n  } else if (key == LogicalKeyboardKey.pageUp) {\n    _navigateDaysBy(-7);\n    return KeyEventResult.handled;\n  } else if (key == LogicalKeyboardKey.pageDown) {\n    _navigateDaysBy(7);\n    return KeyEventResult.handled;\n  }\n  \n  return KeyEventResult.ignored;\n}\n\nvoid _focusPreviousEvent() {\n  final allEvents = _getAllEventsForDay().sortedBy((e) => e.start);\n  final currentIndex = _focusedEvent == null \n    ? allEvents.length \n    : allEvents.indexOf(_focusedEvent!);\n  \n  if (currentIndex > 0) {\n    setState(() {\n      _focusedEvent = allEvents[currentIndex - 1];\n      _focusedEventIndex = currentIndex - 1;\n    });\n    _scrollToEvent(_focusedEvent!);\n    _announceEventFocus(_focusedEvent!);\n  }\n}\n\nvoid _enterKeyboardMoveMode(MCalCalendarEvent event) {\n  setState(() {\n    _isKeyboardMoveMode = true;\n    _keyboardMoveEvent = event;\n    _keyboardMoveOriginalStart = event.start;\n    _keyboardMoveOriginalEnd = event.end;\n  });\n  \n  _dragHandler?.startDrag(event, event.start);\n  _announceScreenReader('Selected ${event.title}. Use arrow keys to move, R to resize, Enter to confirm, Escape to cancel.');\n}\n\nKeyEventResult _handleKeyboardMove(LogicalKeyboardKey key) {\n  if (_keyboardMoveEvent == null) return KeyEventResult.ignored;\n  \n  if (key == LogicalKeyboardKey.keyR && widget.enableDragToResize) {\n    _enterKeyboardResizeMode();\n    return KeyEventResult.handled;\n  } else if (key == LogicalKeyboardKey.arrowUp) {\n    _adjustKeyboardMoveTime(const Duration(minutes: -15));\n    return KeyEventResult.handled;\n  } else if (key == LogicalKeyboardKey.arrowDown) {\n    _adjustKeyboardMoveTime(const Duration(minutes: 15));\n    return KeyEventResult.handled;\n  } else if (key == LogicalKeyboardKey.arrowLeft) {\n    _adjustKeyboardMoveDay(-1);\n    return KeyEventResult.handled;\n  } else if (key == LogicalKeyboardKey.arrowRight) {\n    _adjustKeyboardMoveDay(1);\n    return KeyEventResult.handled;\n  } else if (key == LogicalKeyboardKey.enter) {\n    _confirmKeyboardMove();\n    return KeyEventResult.handled;\n  } else if (key == LogicalKeyboardKey.escape) {\n    _cancelKeyboardMove();\n    return KeyEventResult.handled;\n  }\n  \n  return KeyEventResult.ignored;\n}\n\nvoid _enterKeyboardResizeMode() {\n  setState(() {\n    _isKeyboardMoveMode = false;\n    _isKeyboardResizeMode = true;\n    _keyboardResizeEdge = MCalResizeEdge.end;\n  });\n  \n  _dragHandler?.startResize(_keyboardMoveEvent!, MCalResizeEdge.end);\n  _announceScreenReader('Resize mode. Adjusting end time. Use arrow keys to resize, S for start, E for end, M to return to move, Enter to confirm, Escape to cancel.');\n}\n```\n\n**Dependencies:** `MCalDragHandler`, `SemanticsService`\n\n**Reuses:** Month view keyboard navigation patterns exactly\n\n### Component 13: Day Navigator\n\n**Purpose:** Previous/Today/Next navigation controls.\n\n**Widget:** `_DayNavigator` (private StatelessWidget) or builder-provided\n\n**Design:**\n```dart\nclass _DayNavigator extends StatelessWidget {\n  final DateTime displayDate;\n  final bool canGoPrevious;\n  final bool canGoNext;\n  final VoidCallback onPrevious;\n  final VoidCallback onToday;\n  final VoidCallback onNext;\n  final String? dateFormat;\n  final Locale locale;\n  final MCalThemeData theme;\n  \n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      height: 56.0,\n      color: theme.navigatorBackgroundColor,\n      child: Row(\n        children: [\n          IconButton(\n            icon: const Icon(Icons.chevron_left),\n            onPressed: canGoPrevious ? onPrevious : null,\n            tooltip: 'Previous day',\n          ),\n          IconButton(\n            icon: const Icon(Icons.today),\n            onPressed: onToday,\n            tooltip: 'Today',\n          ),\n          Expanded(\n            child: Center(\n              child: Text(\n                _formatDate(displayDate, dateFormat, locale),\n                style: theme.navigatorTextStyle,\n              ),\n            ),\n          ),\n          IconButton(\n            icon: const Icon(Icons.chevron_right),\n            onPressed: canGoNext ? onNext : null,\n            tooltip: 'Next day',\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n**Dependencies:** Theme, intl\n\n**Reuses:** Month view navigator pattern (adapted from month to day)\n\n## Data Models\n\n### MCalTimeRange\n\n```dart\n/// Represents a time range configuration for the day view.\nclass MCalTimeRange {\n  /// Starting hour (0-23).\n  final int startHour;\n  \n  /// Ending hour (0-23).\n  final int endHour;\n  \n  /// Time slot duration for snapping.\n  final Duration timeSlotDuration;\n  \n  const MCalTimeRange({\n    required this.startHour,\n    required this.endHour,\n    required this.timeSlotDuration,\n  });\n  \n  /// Validates that start < end.\n  bool get isValid => startHour < endHour && startHour >= 0 && endHour <= 23;\n  \n  /// Total number of hours in range.\n  int get totalHours => endHour - startHour + 1;\n}\n```\n\n### MCalDayEventLayout\n\n```dart\n/// Layout information for a timed event in the day view.\nclass MCalDayEventLayout {\n  /// The event being laid out.\n  final MCalCalendarEvent event;\n  \n  /// Column index (0-based) for overlap handling.\n  final int columnIndex;\n  \n  /// Total number of columns needed for this overlap group.\n  final int totalColumns;\n  \n  /// Vertical offset from top in pixels.\n  final double topOffset;\n  \n  /// Height in pixels.\n  final double height;\n  \n  /// Calculated start time (may differ from event.start due to rounding).\n  final DateTime startTime;\n  \n  /// Calculated end time.\n  final DateTime endTime;\n  \n  const MCalDayEventLayout({\n    required this.event,\n    required this.columnIndex,\n    required this.totalColumns,\n    required this.topOffset,\n    required this.height,\n    required this.startTime,\n    required this.endTime,\n  });\n}\n```\n\n### Context Objects (in mcal_day_view_contexts.dart)\n\n**MCalTimeSlotContext:**\n```dart\nclass MCalTimeSlotContext {\n  final DateTime date;\n  final DateTime time;\n  final bool isAllDayArea;\n  final int? hour;\n  final int? minute;\n  \n  const MCalTimeSlotContext({\n    required this.date,\n    required this.time,\n    required this.isAllDayArea,\n    this.hour,\n    this.minute,\n  });\n}\n```\n\n**MCalTimeLabelContext:**\n```dart\nclass MCalTimeLabelContext {\n  final int hour;\n  final DateTime time;\n  final Locale locale;\n  \n  const MCalTimeLabelContext({\n    required this.hour,\n    required this.time,\n    required this.locale,\n  });\n}\n```\n\n**MCalTimedEventTileContext:**\n```dart\nclass MCalTimedEventTileContext {\n  final MCalCalendarEvent event;\n  final DateTime displayDate;\n  final int columnIndex;\n  final int totalColumns;\n  final DateTime startTime;\n  final DateTime endTime;\n  final bool isFocused;\n  final bool isBeingDragged;\n  final bool isDropTargetPreview;\n  \n  const MCalTimedEventTileContext({\n    required this.event,\n    required this.displayDate,\n    required this.columnIndex,\n    required this.totalColumns,\n    required this.startTime,\n    required this.endTime,\n    this.isFocused = false,\n    this.isBeingDragged = false,\n    this.isDropTargetPreview = false,\n  });\n}\n```\n\n**MCalDayHeaderContext:**\n```dart\nclass MCalDayHeaderContext {\n  final DateTime date;\n  final bool isToday;\n  final Locale locale;\n  \n  const MCalDayHeaderContext({\n    required this.date,\n    required this.isToday,\n    required this.locale,\n  });\n}\n```\n\n**MCalCurrentTimeContext:**\n```dart\nclass MCalCurrentTimeContext {\n  final DateTime currentTime;\n  final double offset;\n  final bool isRTL;\n  \n  const MCalCurrentTimeContext({\n    required this.currentTime,\n    required this.offset,\n    required this.isRTL,\n  });\n}\n```\n\n**MCalGridlineContext:**\n```dart\nclass MCalGridlineContext {\n  final int hour;\n  final bool isHalfHour;\n  \n  const MCalGridlineContext({\n    required this.hour,\n    required this.isHalfHour,\n  });\n}\n```\n\n**MCalDayLayoutContext:**\n```dart\n/// Context for custom day layout builder.\nclass MCalDayLayoutContext {\n  final List<MCalCalendarEvent> events;\n  final DateTime displayDate;\n  final int startHour;\n  final int endHour;\n  final double hourHeight;\n  final double areaWidth;\n  \n  const MCalDayLayoutContext({\n    required this.events,\n    required this.displayDate,\n    required this.startHour,\n    required this.endHour,\n    required this.hourHeight,\n    required this.areaWidth,\n  });\n}\n```\n\n### Callback Detail Classes (extend mcal_callback_details.dart)\n\n**MCalEventDroppedDetails extension:**\n```dart\n// Add field to existing class\nclass MCalEventDroppedDetails {\n  // ... existing fields ...\n  \n  /// Indicates event type conversion: 'allDayToTimed', 'timedToAllDay', or null.\n  final String? typeConversion;\n  \n  const MCalEventDroppedDetails({\n    // ... existing parameters ...\n    this.typeConversion,\n  });\n}\n```\n\n## Error Handling\n\n### Error Scenarios\n\n1. **Time calculations exceed day boundaries**\n   - **Handling:** Clamp to `startHour:00` and `endHour:00`, or reject drag/resize if invalid\n   - **User Impact:** Event snaps to boundary or shows invalid feedback\n\n2. **Drag callback returns false**\n   - **Handling:** `onEventDropped` returns false → revert event to original position, `dragHandler.cancelDrag()`\n   - **User Impact:** Event animates back to original position (or snaps if animations disabled)\n\n3. **Resize below minimum duration**\n   - **Handling:** Enforce minimum of 1 time slot, prevent edge from crossing opposite edge\n   - **User Impact:** Handle stops moving when minimum is reached\n\n4. **Invalid time range (startHour >= endHour)**\n   - **Handling:** Assert in debug, clamp in release, or show error via `errorBuilder`\n   - **User Impact:** Error message or clamped to valid range\n\n5. **Controller loading fails**\n   - **Handling:** Show error UI via `errorBuilder` callback\n   - **User Impact:** Error message with retry option\n\n6. **Scroll controller disposed during animation**\n   - **Handling:** Check `mounted` before all `setState` calls, cancel timers in `dispose`\n   - **User Impact:** None - silent failure prevention\n\n7. **Cross-day navigation at boundaries**\n   - **Handling:** Check `canNavigateTo(date)` before navigating, disable edge navigation at limits\n   - **User Impact:** Edge navigation stops at `minDate`/`maxDate`\n\n8. **Overlapping events calculation fails**\n   - **Handling:** Catch exceptions in overlap detection, fall back to stacked layout\n   - **User Impact:** Events stack instead of showing side-by-side (degraded but functional)\n\n## Testing Strategy\n\n### Unit Testing\n\n**Time Utilities (`test/utils/time_utils_test.dart`):**\n- Test `timeToOffset()` with various hours, minutes, hour heights\n- Test `offsetToTime()` with various offsets, slot durations (1, 5, 10, 15, 30, 60 minutes)\n- Test time slot snapping edge cases (midnight, boundaries, DST transitions)\n- Test `durationToHeight()` calculations\n- Verify DST-safe behavior (time calculations near spring-forward/fall-back)\n\n**Overlap Detection (`test/utils/overlap_detection_test.dart` or inline tests):**\n- Single event: Returns 1 column\n- Two non-overlapping events: Returns 1 column each\n- Two overlapping events: Returns 2 columns\n- Three events with partial overlap: Correct column assignment\n- All events overlap: Returns n columns for n events\n- Events with identical times: Sorted by duration (longest first)\n- Zero-duration events: Handled gracefully\n\n### Widget Testing\n\n**Layout Rendering (`test/widgets/mcal_day_view_test.dart`):**\n- Time legend renders with correct hour count and positioning (LTR/RTL)\n- Gridlines render at correct intervals (hour and half-hour)\n- Day header displays correct date and position\n- All-day section renders events horizontally\n- All-day overflow indicator shows when events exceed `maxRows`\n- Timed events render at correct vertical positions\n- Event heights match duration\n- Overlapping events render in columns\n- Current time indicator renders on today, updates position\n- Empty day renders without errors\n\n**Drag and Drop (`test/widgets/mcal_day_view_drag_test.dart`):**\n- Long-press initiates drag\n- Vertical drag updates proposed time\n- Drop target preview renders at proposed position\n- Time slot snapping works correctly\n- `onDragWillAccept` validation called with correct times\n- `onEventDropped` called on release with correct details\n- Drag cancellation (Escape key, invalid drop) works\n- Edge navigation triggers at left/right edges\n- Cross-day drag preserves time-of-day\n- Timed → all-day conversion works when dropped in all-day section\n- All-day → timed conversion works when dropped in timed section\n- Converted event has correct times/dates\n\n**Resize (`test/widgets/mcal_day_view_resize_test.dart`):**\n- Top edge resize changes start time\n- Bottom edge resize changes end time\n- Minimum duration enforced (1 time slot)\n- `onResizeWillAccept` validation called\n- `onEventResized` called with correct details\n- Resize handles render on timed events\n- All-day events have horizontal resize handles\n- Edge navigation during resize works\n- Cross-day resize preserves event correctly\n\n**Keyboard Navigation (`test/widgets/mcal_day_view_keyboard_test.dart`):**\n- Arrow keys navigate days and events\n- Enter/Space enters move mode\n- R key enters resize mode\n- Move mode: arrows adjust time/date\n- Resize mode: arrows adjust edge, S/E switch edge, M exits\n- Screen reader announcements occur\n- Validation applies to keyboard operations\n\n**RTL Support (`test/widgets/mcal_day_view_rtl_test.dart`):**\n- Time legend on right side\n- Day header at top-right\n- Current time indicator dot on right\n- All drag/resize operations work correctly\n- Edge navigation directions reversed\n\n### Integration Testing\n\n**Complete Workflows (`test/integration/mcal_day_view_integration_test.dart`):**\n- Create event via time slot tap → drag → drop → verify in controller\n- Create event → resize top edge → verify updated duration\n- Recurring event → drag → verify modified exception created\n- All-day event → drag to timed section → verify conversion\n- Timed event → drag to all-day → verify conversion\n- Navigate to yesterday → today → tomorrow → verify dates\n- Auto-scroll to current time on load → verify scroll position\n- Load 50+ events → verify performance (frame times)\n\n### Performance Testing\n\n- Render with 100+ events: Measure frame times (target: <16ms per frame)\n- Scrolling with many events: Verify smooth 60fps\n- Drag operations: Verify 60fps during drag (debounced updates)\n- Memory: Load large event set → verify no leaks → dispose → verify cleanup\n\n## Theme Property Additions to MCalThemeData\n\n**Add to `lib/src/styles/mcal_theme.dart`:**\n\n```dart\nclass MCalThemeData {\n  // ... existing properties ...\n  \n  // Day View: Time Legend\n  final double? timeLegendWidth;\n  final TextStyle? timeLegendTextStyle;\n  final Color? timeLegendBackgroundColor;\n  \n  // Day View: Gridlines\n  final Color? hourGridlineColor;\n  final Color? halfHourGridlineColor;\n  final double? hourGridlineWidth;\n  final double? halfHourGridlineWidth;\n  \n  // Day View: Current Time Indicator\n  final Color? currentTimeIndicatorColor;\n  final double? currentTimeIndicatorWidth;\n  final double? currentTimeIndicatorDotRadius;\n  \n  // Day View: All-Day Section\n  final double? allDaySectionHeight;\n  final int? allDaySectionMaxRows;\n  \n  // Day View: Timed Events\n  final double? hourHeight;\n  final double? timedEventMinHeight;\n  final double? timedEventBorderRadius;\n  final EdgeInsets? timedEventPadding;\n  \n  // ... constructor, copyWith, lerp, fromTheme updates ...\n}\n```\n\n**Default values in `fromTheme()`:**\n```dart\nstatic MCalThemeData fromTheme(ThemeData theme) {\n  final colorScheme = theme.colorScheme;\n  final textTheme = theme.textTheme;\n  \n  return MCalThemeData(\n    // ... existing defaults ...\n    \n    // Day view defaults\n    timeLegendWidth: 60.0,\n    timeLegendTextStyle: textTheme.labelSmall?.copyWith(\n      color: colorScheme.onSurfaceVariant,\n    ),\n    timeLegendBackgroundColor: colorScheme.surfaceContainerLow,\n    hourGridlineColor: colorScheme.outline.withValues(alpha: 0.2),\n    halfHourGridlineColor: colorScheme.outline.withValues(alpha: 0.1),\n    currentTimeIndicatorColor: colorScheme.primary,\n    currentTimeIndicatorWidth: 2.0,\n    currentTimeIndicatorDotRadius: 6.0,\n    allDaySectionMaxRows: 3,\n    timedEventMinHeight: 20.0,\n    timedEventBorderRadius: 4.0,\n    timedEventPadding: const EdgeInsets.all(2.0),\n  );\n}\n```\n\n## Widget Hierarchy\n\n```\nMCalDayView\n└─ _MCalDayViewState\n    └─ Column\n        ├─ _DayNavigator (if showNavigator)\n        │   └─ Row [Prev | Today | Date | Next]\n        │\n        └─ Expanded\n            └─ Row\n                ├─ _TimeLegendColumn (if !isRTL)\n                │   └─ Stack [Hour labels positioned]\n                │\n                ├─ Expanded (events area)\n                │   └─ Column\n                │       ├─ _DayHeader\n                │       │   └─ Positioned (top-left or top-right)\n                │       │\n                │       ├─ _AllDayEventsSection\n                │       │   └─ Wrap [All-day event tiles]\n                │       │\n                │       └─ Expanded\n                │           └─ SingleChildScrollView (vertical)\n                │               └─ DragTarget (for drop handling)\n                │                   └─ Stack (5 layers)\n                │                       ├─ Layer 1: _GridlinesLayer\n                │                       ├─ Layer 2: _TimedEventsLayer\n                │                       │   └─ Stack [Positioned event tiles]\n                │                       ├─ Layer 3: _CurrentTimeIndicator\n                │                       ├─ Layer 4: _DropTargetPreviewLayer (ListenableBuilder)\n                │                       │   └─ Stack [Preview tiles at proposed position]\n                │                       └─ Layer 5: _DropTargetOverlayLayer (ListenableBuilder)\n                │                           └─ Container [Highlighted time slots]\n                │\n                └─ _TimeLegendColumn (if isRTL)\n```\n\n## Layered Rendering (similar to month view)\n\n**Layer 1: Gridlines**\n- Renders first (bottom of stack)\n- Static positioning based on hour intervals\n- Conditional rendering based on `showHalfHourLines`\n\n**Layer 2: Event Tiles**\n- Timed events with absolute positioning\n- Column layout for overlaps\n- Drag sources via `MCalDraggableEventTile`\n- Resize handles when enabled\n\n**Layer 3: Current Time Indicator**\n- Renders above events (more visible)\n- Positioned absolutely based on current time\n- Updates every minute via timer\n\n**Layer 4: Drop Target Preview**\n- Wrapped in `ListenableBuilder` listening to `MCalDragHandler`\n- Shows phantom event tile at proposed drop position\n- Opacity or border indicates valid/invalid\n- Updates in real-time during drag\n\n**Layer 5: Drop Target Overlay**\n- Wrapped in `ListenableBuilder`\n- Highlights time slot range being targeted\n- Semi-transparent overlay\n- Renders above all other layers for visibility\n\n## State Management\n\n**Widget State (_MCalDayViewState):**\n```dart\nclass _MCalDayViewState extends State<MCalDayView> {\n  // Controller integration\n  late DateTime _displayDate;\n  List<MCalCalendarEvent> _allEvents = [];\n  List<MCalCalendarEvent> _allDayEvents = [];\n  List<MCalCalendarEvent> _timedEvents = [];\n  bool _isLoading = false;\n  Object? _error;\n  \n  // Drag state\n  MCalDragHandler? _dragHandler;\n  bool _isDragActive = false;\n  bool _isResizeActive = false;\n  \n  // Scroll state\n  ScrollController? _scrollController;\n  bool _autoScrollDone = false;\n  \n  // Layout cache\n  double _cachedHourHeight = 0.0;\n  double _cachedAreaWidth = 0.0;\n  \n  // Keyboard state\n  FocusNode _focusNode = FocusNode();\n  MCalCalendarEvent? _focusedEvent;\n  int _focusedEventIndex = -1;\n  bool _isKeyboardMoveMode = false;\n  bool _isKeyboardResizeMode = false;\n  MCalCalendarEvent? _keyboardMoveEvent;\n  DateTime? _keyboardMoveOriginalStart;\n  DateTime? _keyboardMoveOriginalEnd;\n  MCalResizeEdge _keyboardResizeEdge = MCalResizeEdge.end;\n  \n  // Current time\n  Timer? _currentTimeTimer;\n  DateTime _currentTime = DateTime.now();\n  \n  // Keys for layout access\n  final GlobalKey _timedEventsAreaKey = GlobalKey();\n  \n  @override\n  void initState() {\n    super.initState();\n    _displayDate = widget.controller.displayDate;\n    _scrollController = widget.scrollController ?? ScrollController();\n    widget.controller.addListener(_onControllerChanged);\n    _loadEvents();\n    _startCurrentTimeTimer();\n  }\n  \n  @override\n  void dispose() {\n    _currentTimeTimer?.cancel();\n    _dragHandler?.dispose();\n    _focusNode.dispose();\n    if (widget.scrollController == null) {\n      _scrollController?.dispose();\n    }\n    widget.controller.removeListener(_onControllerChanged);\n    super.dispose();\n  }\n}\n```\n\n## RTL Support Implementation\n\n**Detection:**\n```dart\nbool _isRTL(BuildContext context) {\n  final localizations = MCalLocalizations();\n  final resolvedLocale = widget.locale ?? Localizations.localeOf(context);\n  return localizations.isRTL(resolvedLocale);\n}\n```\n\n**Application:**\n- Time legend: `if (!isRTL) _TimeLegendColumn(...) else Expanded(...)`\n- Day header: `Align(alignment: isRTL ? Alignment.topRight : Alignment.topLeft, ...)`\n- Current time indicator dot: `if (!isRTL) _buildDot() else Expanded(...)`\n- Edge navigation: `nearLeftEdge` → navigate to `isRTL ? next : previous` day\n- All builder contexts include `isRTL` field for custom rendering\n\n## Navigation Pattern\n\n**Approach:** Single-page with `setState` (simpler than PageView)\n\nUnlike month view which uses `PageView.builder` for infinite scrolling, day view uses a simpler approach:\n- Display date stored in `_displayDate` state field\n- Navigation methods call `setState(() { _displayDate = newDate; })`\n- Controller updated via `widget.controller.setDisplayDate(newDate)`\n- Events reloaded via `_loadEvents()` which calls `controller.getEventsForRange()`\n\n**Why simpler approach:**\n- Single day is lighter weight than full month grid\n- No need for \"infinite\" scrolling (PageView complexity)\n- Faster navigation (no animation overhead unless desired)\n- Easier to implement cross-day drag persistence (no page widget disposal)\n\n**Animation (if enabled):**\n- Can animate `_displayDate` change using `AnimatedSwitcher` or custom transition\n- Respects `enableAnimations` and OS reduced motion preference\n\n## Performance Optimizations\n\n1. **Lazy drag handler creation**: Only create `MCalDragHandler` when first drag occurs\n2. **Cached layout values**: Store `_cachedHourHeight`, `_cachedAreaWidth` in `didChangeDependencies`\n3. **Viewport-based rendering**: Only render events within visible scroll region (+ buffer)\n4. **Debounced drag updates**: Use same 16ms debounce as month view for 60fps\n5. **Const constructors**: Use `const` where possible for immutable widgets\n6. **ListView vs Stack**: Use `Stack` with `Positioned` (not `ListView`) for precise event positioning\n7. **Timer efficiency**: Current time timer fires once per minute (not continuously)\n8. **Controller listener**: Only rebuild when events for displayed date change\n\n## Accessibility Implementation\n\n**Semantic Labels:**\n- Time legend hours: \"9 AM\", \"2 PM\", etc.\n- Event tiles: \"{title}, {start time} to {end time}, {duration}\"\n- Current time indicator: \"Current time: {time}\"\n- Navigator buttons: \"Previous day\", \"Today\", \"Next day\"\n- Resize handles: \"Resize start time\" / \"Resize end time\"\n\n**Screen Reader Announcements:**\n```dart\nvoid _announceScreenReader(String message) {\n  SemanticsService.announce(\n    message,\n    Directionality.of(context),\n  );\n}\n\n// Examples:\n_announceScreenReader('Moving Team Meeting to 2:30 PM');\n_announceScreenReader('Moved Team Meeting to 2:30 PM on Wednesday, February 14');\n_announceScreenReader('Resize mode. Adjusting end time.');\n_announceScreenReader('Resizing Team Meeting end to 4:00 PM, 2 hours');\n```\n\n**Focus Management:**\n- `FocusNode` attached to day view root\n- `onKeyEvent` handler for keyboard navigation\n- `requestFocus()` on event tap when `autoFocusOnEventTap` is true\n- Focus indicator via `focusedEventBorderColor` or custom style\n\n**Reduced Motion:**\n```dart\nbool _resolveAnimationsEnabled(BuildContext context) {\n  if (widget.enableAnimations != null) return widget.enableAnimations!;\n  return !MediaQuery.disableAnimationsOf(context);\n}\n```\n\n## Integration with Existing Systems\n\n**MCalEventController:**\n- Call `getEventsForRange()` for single day: `DateTimeRange(start: dayStart, end: dayEnd)`\n- Listen for changes: `controller.addListener(_onControllerChanged)`\n- Update events: `controller.addEvents([updatedEvent])`\n- Recurring exceptions: `controller.modifyOccurrence(seriesId, originalDate, modifiedEvent)`\n\n**MCalDragHandler:**\n- Create lazily: `_dragHandler ??= MCalDragHandler()`\n- Start drag: `_dragHandler!.startDrag(event, sourceDate/time)`\n- Update drag: Calculate time from Y position, call `updateProposedDropRange()`\n- Complete drag: `completeDrag()` returns proposed time, update controller\n- Start resize: `_dragHandler!.startResize(event, edge)`\n- Update resize: Calculate new time, call `updateResize()`\n- Complete resize: `completeResize()` returns times, update controller\n\n**MCalTheme:**\n- Read: `final theme = MCalTheme.of(context)`\n- Apply: Use theme properties throughout rendering\n- Builder contexts: Pass theme-relevant properties in context objects\n\n## Builder Pattern Examples\n\n**Day Layout Builder (custom overlap layout):**\n```dart\ndayLayoutBuilder: (context, layoutContext) {\n  // Custom layout: stack events with offset instead of columns\n  return Stack(\n    children: layoutContext.events.map((event) {\n      final index = layoutContext.events.indexOf(event);\n      return Positioned(\n        top: timeToOffset(event.start, ...),\n        left: index * 4.0,  // 4px offset per event\n        right: 0,\n        height: durationToHeight(event.end.difference(event.start), ...),\n        child: Container(...),  // Custom tile rendering\n      );\n    }).toList(),\n  );\n}\n```\n\n**Time Label Builder:**\n```dart\ntimeLabelBuilder: (context, labelContext) {\n  return Text(\n    '${labelContext.hour}:00',\n    style: TextStyle(fontSize: 10, color: Colors.grey),\n  );\n}\n```\n\n## File Organization\n\n**Main widget file:** `lib/src/widgets/mcal_day_view.dart` (~6,000-7,000 lines)\n- `MCalDayView` widget class (~200 lines)\n- `_MCalDayViewState` class (~800 lines)\n- `_DayNavigator` widget (~100 lines)\n- `_TimeLegendColumn` widget (~150 lines)\n- `_GridlinesLayer` widget (~100 lines)\n- `_AllDayEventsSection` widget and state (~400 lines)\n- `_TimedEventsLayer` widget (~300 lines)\n- `_CurrentTimeIndicator` widget and state (~150 lines)\n- `_TimeResizeHandle` widget (~100 lines)\n- Helper methods (~3,000+ lines for drag, resize, keyboard, layout calculations)\n\n**Contexts file:** `lib/src/widgets/mcal_day_view_contexts.dart` (~600-800 lines)\n- 8-10 context classes (~60-80 lines each)\n\n**Time utilities:** `lib/src/utils/time_utils.dart` (~300-400 lines)\n- Pure functions for time calculations\n- Overlap detection algorithm (~100 lines)\n- Time formatting helpers (~50 lines)\n\n## Example App Integration Pattern\n\n**Showcase widget** (`example/lib/views/day_view/day_view_showcase.dart`):\n```dart\nclass DayViewShowcase extends StatefulWidget {\n  final Locale currentLocale;\n  final bool isDarkMode;\n  \n  @override\n  State<DayViewShowcase> createState() => _DayViewShowcaseState();\n}\n\nclass _DayViewShowcaseState extends State<DayViewShowcase> \n    with SingleTickerProviderStateMixin {\n  late TabController _tabController;\n  late MCalEventController _eventController;\n  DateTime? _selectedDate;\n  \n  static const _styles = [\n    StyleTabInfo(name: 'Default', description: 'Out-of-the-box...'),\n    StyleTabInfo(name: 'Modern', description: 'Rounded and elevated...'),\n    StyleTabInfo(name: 'Classic', description: 'Traditional grid...'),\n    StyleTabInfo(name: 'Minimal', description: 'Ultra-clean...'),\n    StyleTabInfo(name: 'Colorful', description: 'Bold and vibrant...'),\n    StyleTabInfo(name: 'Features Demo', description: 'Interactive controls...'),\n  ];\n  \n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        TabBar(controller: _tabController, tabs: _buildTabs()),\n        Expanded(\n          child: TabBarView(\n            controller: _tabController,\n            children: [\n              DefaultDayStyle(controller: _eventController, ...),\n              ModernDayStyle(controller: _eventController, ...),\n              ClassicDayStyle(controller: _eventController, ...),\n              MinimalDayStyle(controller: _eventController, ...),\n              ColorfulDayStyle(controller: _eventController, ...),\n              FeaturesDemoDayStyle(controller: _eventController, ...),\n            ],\n          ),\n        ),\n      ],\n    );\n  }\n}\n```\n\n**Each style file pattern:**\n```dart\nclass ModernDayStyle extends StatelessWidget {\n  final MCalEventController eventController;\n  final Locale locale;\n  final bool isDarkMode;\n  final String description;\n  \n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        StyleDescription(description: description),\n        Expanded(\n          child: MCalTheme(\n            data: _buildCustomTheme(context),\n            child: MCalDayView(\n              controller: eventController,\n              // ... custom configuration ...\n            ),\n          ),\n        ),\n      ],\n    );\n  }\n}\n```\n\nThis design provides a complete technical blueprint for implementing MCalDayView with all requirements satisfied, following established patterns from MCalMonthView, and ensuring consistency across the package.\n",
  "fileStats": {
    "size": 72131,
    "lines": 2288,
    "lastModified": "2026-02-14T06:26:19.962Z"
  },
  "comments": []
}