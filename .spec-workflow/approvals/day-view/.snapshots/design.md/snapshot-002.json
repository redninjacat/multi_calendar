{
  "id": "snapshot_1771052354792_9l0hn45zb",
  "approvalId": "approval_1771050387386_ctfiq1bne",
  "approvalTitle": "Day View Design Document",
  "version": 2,
  "timestamp": "2026-02-14T06:59:14.792Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document: Day View\n\n## Overview\n\nThis design document details the technical implementation of `MCalDayView` - a vertical timeline calendar view displaying a single day's schedule. The day view presents time-based events in proportion to their duration, with automatic overlap detection and column-based layout for concurrent events.\n\nThe architecture follows established patterns from `MCalMonthView` (7,834 lines), reusing the `MCalDragHandler` state machine, `MCalEventController` integration, theme system, and context object patterns. The view supports:\n- Configurable time ranges (e.g., 8am-6pm, full 24-hour)\n- Day header with date/day-of-week and **optional ISO week number** (NEW - inspired by Kalender)\n- All-day events section at top with drag/resize (platform-restricted)\n- Timed events area with Google Calendar-style overlap layout\n- Current time indicator with automatic minute updates\n- Vertical scrolling with auto-scroll to current time\n- Drag-to-move (vertical + cross-day edge navigation)\n- Drag-to-resize (top/bottom edges + cross-day navigation)\n- Event type conversion (all-day ↔ timed via drag)\n- **Snap-to-time functionality** (NEW - inspired by Kalender): Events snap to time slots, nearby events, and current time during drag/resize operations\n- **Special time regions** (NEW - inspired by Syncfusion): Visual styling and interaction blocking for time periods (e.g., lunch breaks, non-working hours)\n- **Empty time slot gestures** (NEW - adapted from month view): Tap and long-press handlers for empty time slots (e.g., event creation)\n- Complete keyboard navigation\n- Full RTL support throughout\n\n## New Features (Competitive Analysis)\n\n### 1. Snap-to-Time Functionality (Inspired by Kalender)\n\n**Purpose:** Improves UX during drag-and-drop operations by automatically aligning events to meaningful time boundaries.\n\n**Features:**\n- **Snap to time slots**: Events align to configured intervals (e.g., 15-minute marks)\n- **Snap to other events**: Magnetic snapping to nearby event boundaries (start/end times)\n- **Snap to current time**: Events near \"now\" snap to current time indicator\n- **Configurable snap range**: Define proximity threshold (default: 5 minutes)\n\n**Configuration:**\n```dart\nMCalDayView(\n  snapToTimeSlots: true,        // Snap to 15-minute intervals\n  snapToOtherEvents: true,      // Magnetic snap to nearby events\n  snapToCurrentTime: true,      // Snap to \"now\"\n  snapRange: Duration(minutes: 5),  // Snapping threshold\n)\n```\n\n**Behavior:**\n1. User drags event to 9:07 AM → snaps to 9:00 AM (time slot)\n2. User drags near another event at 10:30 AM → snaps to 10:30 AM (magnetic)\n3. User drags near current time (11:23 AM) → snaps to 11:15 AM (current time, rounded to slot)\n\n### 2. Special Time Regions (Inspired by Syncfusion)\n\n**Purpose:** Visual styling and interaction control for specific time periods, adapted from month view's blockout days pattern.\n\n**Features:**\n- **Visual customization**: Custom colors, text, and icons for regions\n- **Interaction blocking**: Prevent event drops/taps in designated regions (similar to month view blockout dates)\n- **Recurring regions**: Support RFC 5545 RRULE for patterns (daily lunch, weekends)\n- **Custom builder**: Full control via `timeRegionBuilder` callback\n\n**Configuration:**\n```dart\nMCalDayView(\n  specialTimeRegions: [\n    // Lunch break (visual only, allows drops)\n    MCalTimeRegion(\n      id: 'lunch',\n      startTime: DateTime(2026, 2, 14, 12, 0),\n      endTime: DateTime(2026, 2, 14, 13, 0),\n      color: Colors.amber.withValues(alpha: 0.3),\n      text: 'Lunch Break',\n      icon: Icons.restaurant,\n      blockInteraction: false,\n    ),\n    \n    // Non-working hours (blocks drops, like month view blockout dates)\n    MCalTimeRegion(\n      id: 'after-hours',\n      startTime: DateTime(2026, 2, 14, 18, 0),\n      endTime: DateTime(2026, 2, 14, 23, 59),\n      color: Colors.grey.withValues(alpha: 0.5),\n      text: 'After Hours',\n      icon: Icons.block,\n      blockInteraction: true,  // Rejects drops via validation\n    ),\n    \n    // Recurring morning focus time\n    MCalTimeRegion(\n      id: 'focus-time',\n      startTime: DateTime(2026, 2, 14, 9, 0),\n      endTime: DateTime(2026, 2, 14, 10, 0),\n      recurrenceRule: 'FREQ=DAILY;COUNT=30',\n      color: Colors.blue.withValues(alpha: 0.2),\n      text: 'Focus Time',\n      blockInteraction: true,\n    ),\n  ],\n  \n  // Custom builder for advanced styling\n  timeRegionBuilder: (context, regionContext) {\n    if (regionContext.region.id == 'lunch') {\n      return CustomLunchRegionWidget(region: regionContext.region);\n    }\n    return null; // Use default\n  },\n  \n  // Validation callback (similar to month view onDragWillAccept)\n  onDragWillAccept: (context, details) {\n    // Custom validation logic\n    // Framework automatically checks blocked regions\n    return true;\n  },\n)\n```\n\n**Validation Flow** (similar to month view blockout dates):\n1. User drags event to 18:30 (within blocked \"after-hours\" region)\n2. `_validateDrop()` checks `blockInteraction: true` regions\n3. Drop rejected → visual feedback shows invalid drop\n4. Similar to month view's `onDragWillAccept` rejecting drops on blockout dates\n\n**Use Cases:**\n- **Non-working hours**: Gray out 6pm-8am, block drops\n- **Lunch breaks**: Daily 12-1pm visual indicator (allow or block drops)\n- **Meeting-free zones**: Focus time (9-10am), no interruptions\n- **Holidays/weekends**: Full-day special styling\n- **Custom business rules**: Any time-based restriction with visual feedback\n\n**Comparison to Month View:**\n- Month view: Date-based blockout (blocks entire days)\n- Day view: Time-based regions (fine-grained hour/minute control)\n- Both: Use same validation pattern (`onDragWillAccept` + visual styling)\n\n### 3. Week Number Display (Inspired by Kalender)\n\n**Purpose:** Optional ISO 8601 week number indicator in the day header for users who organize by week.\n\n**Features:**\n- **ISO 8601 standard**: Week 1 is the week containing the first Thursday of the year\n- **RTL support**: Automatically positions left (LTR) or right (RTL)\n- **Theme customization**: Background color, text color, and text style\n- **Builder override**: Full control via `dayHeaderBuilder`\n\n**Configuration:**\n```dart\nMCalDayView(\n  showWeekNumber: true,  // Enable week number display\n  dayHeaderBuilder: (context, headerContext) {\n    // Access headerContext.weekNumber for custom rendering\n    return CustomDayHeader(\n      date: headerContext.date,\n      weekNumber: headerContext.weekNumber,\n      isToday: headerContext.isToday,\n    );\n  },\n)\n```\n\n**Visual Design:**\n```\n┌─────────────────────┐\n│ W7    FRI          │  ← LTR: Week number on left\n│       13           │\n└─────────────────────┘\n\n┌─────────────────────┐\n│          FRI    W7  │  ← RTL: Week number on right\n│           13       │\n└─────────────────────┘\n```\n\n**Use Cases:**\n- **Weekly planning**: Users who think in \"week 7\" terms\n- **Project tracking**: Work organized by ISO weeks\n- **European calendars**: Common in Europe where week numbers are standard\n- **Cross-platform consistency**: Match desktop calendar apps\n\n**Comparison to Month View:**\n- Month view: Week numbers optionally shown in the left gutter of the calendar grid\n- Day view: Week number shown compactly in the day header\n\n### 4. Empty Time Slot Gestures (Adapted from Month View)\n\n**Purpose:** Tap and long-press handling for empty time slots, enabling event creation and custom interactions.\n\n**Inspiration:** Month view's `onCellTap`/`onCellLongPress` for empty day cells.\n\n**Features:**\n- **Tap detection**: `onTimeSlotTap` callback with exact time and position\n- **Long-press detection**: `onTimeSlotLongPress` for extended interactions\n- **Event priority**: Event taps take precedence (gesture absorbed by event tiles)\n- **Time calculation**: Tap position automatically converted to DateTime\n- **Full context**: `MCalTimeSlotContext` provides time, date, and tap position\n\n**Configuration:**\n```dart\nMCalDayView(\n  onTimeSlotTap: (context, timeSlotContext) {\n    print('Tapped at ${timeSlotContext.time}');\n    // Show quick event creation dialog\n    showQuickEventDialog(timeSlotContext.time);\n  },\n  \n  onTimeSlotLongPress: (context, timeSlotContext) {\n    print('Long-pressed at ${timeSlotContext.time}');\n    // Create event immediately at tapped time\n    createEventAt(\n      startTime: timeSlotContext.time,\n      duration: Duration(hours: 1),\n    );\n  },\n)\n```\n\n**Behavior:**\n1. User taps empty space at 2:30 PM → `onTimeSlotTap` fires with `time: 14:30`\n2. User long-presses empty space at 3:15 PM → `onTimeSlotLongPress` fires\n3. User taps on event → Event's `onEventTap` fires (slot tap ignored)\n\n**Use Cases:**\n- **Quick event creation**: Long-press to create event at tapped time\n- **Context menus**: Tap to show available actions for that time slot\n- **Time slot details**: Show information about the time period\n- **Custom interactions**: Developer-defined behavior (analytics, tooltips, etc.)\n\n**Comparison to Month View:**\n| Feature | Month View | Day View |\n|---------|------------|----------|\n| **Callback** | `onCellTap` | `onTimeSlotTap` |\n| **Context** | `MCalCellContext` (date, events) | `MCalTimeSlotContext` (date, time, offset) |\n| **Granularity** | Day-level (full date) | Time-level (hour:minute) |\n| **Use case** | Create all-day event | Create timed event at specific hour |\n| **Pattern** | GestureDetector on cell | GestureDetector on Stack |\n\n**Context Object:**\n```dart\nclass MCalTimeSlotContext {\n  final DateTime date;           // Display date\n  final DateTime time;           // Exact time (snapped to timeSlotDuration)\n  final Offset offset;           // Local tap position\n  final bool isAllDayArea;       // Tapped in all-day vs timed area\n  final int? hour;               // Hour component (0-23)\n  final int? minute;             // Minute component (0-59)\n}\n```\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n\n- **DST-safe time calculations**: All time arithmetic uses `DateTime(year, month, day, hour, minute)` constructor pattern, NEVER `Duration(hours:)` or `Duration(days:)` addition. When adding time slots: `DateTime(y, m, d, h, m).add(Duration(minutes: n))` is acceptable for intra-day calculations.\n- **ChangeNotifier reactivity**: Reuses existing `MCalDragHandler` (extends `ChangeNotifier`) for drag/resize state, ensuring view rebuilds follow the established reactive update path.\n- **intl localization**: Time formatting via `DateFormat` from intl package, hour labels respect locale (12/24-hour format).\n- **flutter_lints**: All public APIs get full dartdoc with examples.\n- **Performance**: O(n²) or better overlap detection, 60fps rendering with 50+ events, debounced drag updates (16ms).\n\n### Project Structure (structure.md)\n\n- New widget: `lib/src/widgets/mcal_day_view.dart` (~6,000-7,000 lines, mirrors month view structure)\n- Context objects: `lib/src/widgets/mcal_day_view_contexts.dart` (~600-800 lines)\n- Time utilities: `lib/src/utils/time_utils.dart` (~300-400 lines, pure functions for time↔offset conversion)\n- Exports: `lib/multi_calendar.dart` exports `MCalDayView` and all context/callback detail classes\n- Tests: `test/widgets/mcal_day_view_test.dart`, `test/utils/time_utils_test.dart`, integration tests\n- Theme extensions: `lib/src/styles/mcal_theme.dart` gains day view properties\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n\n**`MCalDragHandler`** (`lib/src/widgets/mcal_drag_handler.dart`, 915 lines)\n- Drag state machine: `startDrag()`, `updateDrag()`, `completeDrag()`, `cancelDrag()`\n- Resize state machine: `startResize()`, `updateResize()`, `completeResize()`, `cancelResize()`\n- Edge navigation: `handleEdgeProximity()` with self-repeating timer\n- Highlight cells: `_highlightedCells`, `_proposedStartDate`, `_proposedEndDate`, `_isProposedDropValid`\n- **Adaptation needed**: Add helper methods for time-based drag (vertical positioning instead of grid cells)\n\n**`MCalEventController`** (`lib/src/controllers/mcal_event_controller.dart`, 1,284 lines)\n- Event loading: `getEventsForRange()`, `addEvents()`, `removeEvents()`\n- Recurring event expansion: `_getExpandedOccurrences()` handles RRULE\n- Exception handling: `modifyOccurrence()`, `rescheduleOccurrence()`, `cancelOccurrence()`\n- Display date management: `setDisplayDate()`, listener pattern\n- **No changes needed**: Existing API fully supports day view\n\n**`MCalThemeData`** (`lib/src/styles/mcal_theme.dart`)\n- Theme InheritedWidget pattern: `MCalTheme.of(context)`\n- Fallback chain: widget ancestor → extension → `fromTheme()`\n- Existing properties: event tiles, drag feedback, borders, colors\n- **Extension needed**: Add day view-specific properties (time legend, gridlines, hour height, all-day section)\n\n**`MCalLocalizations`** (`lib/src/utils/mcal_localization.dart`)\n- String localization: `getLocalizedString(key, locale)`\n- RTL detection: `isRTL(locale)`\n- Existing strings: English and Spanish (es_MX)\n- **Extension needed**: Add day view-specific strings (time labels, today button, conversion announcements)\n\n**`daysBetween()`** (`lib/src/utils/date_utils.dart`)\n- DST-safe day delta calculation\n- **Reuse for**: Cross-day drag calculations, event type conversion date handling\n\n**Context Object Patterns** (`lib/src/widgets/mcal_month_view_contexts.dart`)\n- `MCalDayCellContext`, `MCalEventTileContext`, `MCalNavigatorContext`, etc.\n- Immutable data classes with all relevant context\n- **Follow pattern for**: `MCalTimeSlotContext`, `MCalTimeLabelContext`, `MCalTimedEventTileContext`, etc.\n\n**Callback Detail Patterns** (`lib/src/widgets/mcal_callback_details.dart`)\n- `MCalEventDroppedDetails`, `MCalEventResizedDetails`, `MCalDragWillAcceptDetails`\n- Immutable classes with full operation details\n- **Extend with**: `typeConversion` field to indicate all-day ↔ timed conversions\n\n### Integration Points\n\n- **MCalEventController**: Day view listens for event updates, calls `getEventsForRange()` for displayed date\n- **MCalDragHandler**: Day view creates handler instance, calls time-based drag methods, listens for state changes\n- **MCalTheme**: Day view reads theme via `MCalTheme.of(context)` with fallback chain\n- **Navigator pattern**: Reuses month view navigator builder pattern with adapted context\n- **PageView approach**: Consider single-page vs. PageView for day navigation (single page + setState preferred for simplicity)\n\n## Architecture\n\n```mermaid\ngraph TD\n    subgraph DayViewWidget [\"MCalDayView Widget\"]\n        State[\"_MCalDayViewState\"] --> Controller[\"MCalEventController\"]\n        State --> DragHandler[\"MCalDragHandler\"]\n        State --> ScrollController[\"ScrollController\"]\n        State --> Timer[\"Current Time Timer\"]\n    end\n    \n    subgraph LayoutStructure [\"Layout Structure\"]\n        Column1[\"Column\"] --> Navigator[\"Navigator Optional\"]\n        Column1 --> MainRow[\"Row TimeArea\"]\n        \n        MainRow --> TimeLegend[\"Time Legend\"]\n        MainRow --> EventsColumn[\"Events Column\"]\n        \n        EventsColumn --> DayHeader[\"Day Header\"]\n        EventsColumn --> AllDaySection[\"All-Day Section\"]\n        EventsColumn --> ScrollView[\"ScrollView Timed\"]\n        \n        ScrollView --> Stack5[\"Stack Layers\"]\n        Stack5 --> L1[\"Layer Gridlines\"]\n        Stack5 --> L2[\"Layer Events\"]\n        Stack5 --> L3[\"Layer TimeIndicator\"]\n        Stack5 --> L4[\"Layer DropPreview\"]\n        Stack5 --> L5[\"Layer DragGesture\"]\n    end\n    \n    subgraph EventLayout [\"Event Layout Engine\"]\n        OverlapDetect[\"Overlap Detection\"] --> ColumnAssign[\"Column Assignment\"]\n        ColumnAssign --> WidthCalc[\"Width Calculation\"]\n        WidthCalc --> Position[\"Positioned Widgets\"]\n    end\n    \n    subgraph DragOperations [\"Drag Operations\"]\n        DragMove[\"Drag to Move\"] --> TimeCalc[\"Time Slot Calc\"]\n        DragResize[\"Drag to Resize\"] --> TimeCalc\n        TimeCalc --> EdgeDetect[\"Edge Detection\"]\n        EdgeDetect --> DayNav[\"Day Navigation\"]\n        \n        TypeConv[\"Type Conversion\"] --> AllDayCheck{\"Drop in AllDay?\"}\n        AllDayCheck -->|Yes| ToAllDay[\"Convert to AllDay\"]\n        AllDayCheck -->|No| ToTimed[\"Convert to Timed\"]\n    end\n    \n    Controller --> DayViewWidget\n    DragHandler --> DragOperations\n    EventLayout --> L2\n```\n\n## Components and Interfaces\n\n### Component 1: MCalDayView Widget Structure\n\n**Purpose:** Top-level stateful widget providing the public API and managing overall state.\n\n**Public API:**\n```dart\nclass MCalDayView extends StatefulWidget {\n  const MCalDayView({\n    super.key,\n    required this.controller,\n    \n    // Time configuration\n    this.startHour = 0,\n    this.endHour = 23,\n    this.timeSlotDuration = const Duration(minutes: 15),\n    this.hourHeight,\n    \n    // Display\n    this.showNavigator = false,\n    this.showCurrentTimeIndicator = true,\n    this.showWeekNumber = false,  // NEW - ISO week number (inspired by Kalender)\n    this.gridlineInterval = const Duration(minutes: 15),  // 1, 5, 10, 15, 20, 30, or 60 minutes\n    this.dateFormat,\n    this.timeLabelFormat,\n    this.locale,\n    \n    // Scrolling\n    this.autoScrollToCurrentTime = true,\n    this.scrollPhysics,\n    this.scrollController,\n    \n    // All-day section\n    this.allDaySectionMaxRows = 3,\n    this.allDayToTimedDuration = const Duration(hours: 1),\n    \n    // Drag and drop\n    this.enableDragToMove = false,\n    this.enableDragToResize,  // null = platform auto-detect\n    this.dragEdgeNavigationEnabled = true,\n    this.dragLongPressDelay = const Duration(milliseconds: 200),\n    this.dragEdgeNavigationDelay = const Duration(milliseconds: 1200),\n    this.showDropTargetPreview = true,\n    this.showDropTargetOverlay = true,\n    this.onDragWillAccept,  // Validate before accepting drop\n    \n    // Snapping (NEW - inspired by Kalender)\n    this.snapToTimeSlots = true,\n    this.snapToOtherEvents = true,\n    this.snapToCurrentTime = true,\n    this.snapRange = const Duration(minutes: 5),\n    \n    // Special time regions (NEW - inspired by Syncfusion)\n    this.specialTimeRegions = const [],\n    this.timeRegionBuilder,\n    \n    // Keyboard\n    this.enableKeyboardNavigation = true,\n    this.autoFocusOnEventTap = true,\n    \n    // Animations\n    this.enableAnimations,  // null = respect OS reduced motion\n    this.animationDuration = const Duration(milliseconds: 300),\n    this.animationCurve = Curves.easeInOut,\n    \n    // Boundaries\n    this.minDate,\n    this.maxDate,\n    \n    // Builders\n    this.dayHeaderBuilder,\n    this.timeLabelBuilder,\n    this.gridlineBuilder,\n    this.allDayEventTileBuilder,\n    this.timedEventTileBuilder,\n    this.currentTimeIndicatorBuilder,\n    this.navigatorBuilder,\n    this.dayLayoutBuilder,\n    this.draggedTileBuilder,\n    this.dropTargetTileBuilder,\n    this.timeResizeHandleBuilder,\n    this.loadingBuilder,\n    this.errorBuilder,\n    \n    // Callbacks\n    this.onDayHeaderTap,\n    this.onDayHeaderLongPress,\n    this.onTimeLabelTap,\n    this.onTimeSlotTap,\n    this.onTimeSlotLongPress,\n    this.onEventTap,\n    this.onEventLongPress,\n    this.onHoverEvent,\n    this.onHoverTimeSlot,\n    this.onOverflowTap,\n    this.onOverflowLongPress,\n    this.onDragWillAccept,\n    this.onEventDropped,\n    this.onResizeWillAccept,\n    this.onEventResized,\n    this.onDisplayDateChanged,\n    this.onScrollChanged,\n    \n    // Semantic label\n    this.semanticsLabel,\n  });\n  \n  // Fields...\n}\n```\n\n**Dependencies:** `MCalEventController`, optional `MCalDragHandler` (lazy-created when drag enabled)\n\n**Reuses:** Month view parameter patterns, callback signatures, builder patterns\n\n### Component 2: Time Calculation Utilities\n\n**Purpose:** Pure functions for converting between time values and pixel offsets.\n\n**Location:** `lib/src/utils/time_utils.dart`\n\n**Functions:**\n```dart\n/// Converts a time to a vertical offset in pixels.\n/// \n/// Returns the distance from the top of the time range to the given time.\ndouble timeToOffset({\n  required DateTime time,\n  required int startHour,\n  required double hourHeight,\n}) {\n  final minutesFromStart = (time.hour - startHour) * 60 + time.minute;\n  return (minutesFromStart / 60.0) * hourHeight;\n}\n\n/// Converts a vertical offset to a time, with optional slot snapping.\n///\n/// Returns a DateTime on the given date with time calculated from offset.\nDateTime offsetToTime({\n  required double offset,\n  required DateTime date,\n  required int startHour,\n  required double hourHeight,\n  required Duration timeSlotDuration,\n}) {\n  final minutesFromStart = (offset / hourHeight) * 60;\n  final snappedMinutes = (minutesFromStart / timeSlotDuration.inMinutes).round() \n    * timeSlotDuration.inMinutes;\n  \n  // DST-safe: construct DateTime with hour/minute\n  final totalMinutes = startHour * 60 + snappedMinutes;\n  final hour = totalMinutes ~/ 60;\n  final minute = totalMinutes % 60;\n  \n  return DateTime(date.year, date.month, date.day, hour, minute);\n}\n\n/// Snaps a time to the nearest time slot boundary.\nDateTime snapToTimeSlot({\n  required DateTime time,\n  required Duration timeSlotDuration,\n}) {\n  final totalMinutes = time.hour * 60 + time.minute;\n  final snappedMinutes = (totalMinutes / timeSlotDuration.inMinutes).round() \n    * timeSlotDuration.inMinutes;\n  \n  final hour = snappedMinutes ~/ 60;\n  final minute = snappedMinutes % 60;\n  \n  return DateTime(time.year, time.month, time.day, hour, minute);\n}\n\n/// Calculates the height in pixels for a duration.\ndouble durationToHeight({\n  required Duration duration,\n  required double hourHeight,\n}) {\n  return (duration.inMinutes / 60.0) * hourHeight;\n}\n```\n\n**Dependencies:** None (pure functions)\n\n**Testing:** Extensive unit tests for DST boundaries, time slot snapping, edge cases\n\n### Component 3: Overlap Detection Algorithm\n\n**Purpose:** Detects overlapping events and assigns them to columns for side-by-side layout.\n\n**Location:** `lib/src/utils/overlap_detection.dart` (new file) or inline in `mcal_day_view.dart`\n\n**Algorithm:**\n```dart\nclass MCalOverlapGroup {\n  final List<MCalCalendarEvent> events;\n  final List<int> columnAssignments;  // index matches events\n  final int totalColumns;\n  \n  const MCalOverlapGroup({\n    required this.events,\n    required this.columnAssignments,\n    required this.totalColumns,\n  });\n}\n\n/// Detects overlapping events and assigns columns.\nMCalOverlapGroup detectOverlapsAndAssignColumns(\n  List<MCalCalendarEvent> events,\n) {\n  if (events.isEmpty) {\n    return const MCalOverlapGroup(\n      events: [],\n      columnAssignments: [],\n      totalColumns: 0,\n    );\n  }\n  \n  // Sort by start time, then by duration (longest first)\n  final sorted = List<MCalCalendarEvent>.from(events)..sort((a, b) {\n    final timeCompare = a.start.compareTo(b.start);\n    if (timeCompare != 0) return timeCompare;\n    // Longer events first\n    return b.end.difference(b.start).compareTo(a.end.difference(a.start));\n  });\n  \n  final columnAssignments = <int>[];\n  final columns = <List<MCalCalendarEvent>>[];\n  \n  for (final event in sorted) {\n    // Find first available column\n    int assignedColumn = -1;\n    for (int col = 0; col < columns.length; col++) {\n      final colEvents = columns[col];\n      // Check if event overlaps with any event in this column\n      bool hasOverlap = false;\n      for (final colEvent in colEvents) {\n        if (_eventsOverlap(event, colEvent)) {\n          hasOverlap = true;\n          break;\n        }\n      }\n      if (!hasOverlap) {\n        assignedColumn = col;\n        break;\n      }\n    }\n    \n    // If no available column, create new one\n    if (assignedColumn == -1) {\n      assignedColumn = columns.length;\n      columns.add([]);\n    }\n    \n    columns[assignedColumn].add(event);\n    columnAssignments.add(assignedColumn);\n  }\n  \n  return MCalOverlapGroup(\n    events: sorted,\n    columnAssignments: columnAssignments,\n    totalColumns: columns.length,\n  );\n}\n\nbool _eventsOverlap(MCalCalendarEvent a, MCalCalendarEvent b) {\n  return a.start.isBefore(b.end) && b.start.isBefore(a.end);\n}\n```\n\n**Complexity:** O(n²) in worst case (all events overlap), O(n·k) average where k is number of columns (typically 2-4)\n\n**Reuses:** Event comparison logic\n\n### Component 4: Day Header with Optional Week Number\n\n**Purpose:** Displays the day of week, date number, and optional ISO week number at the top of the events area.\n\n**Widget:** `_DayHeader` (private StatelessWidget) or builder-provided\n\n**Design:**\n```dart\nclass _DayHeader extends StatelessWidget {\n  final DateTime displayDate;\n  final bool showWeekNumber;\n  final String? dateFormat;\n  final Locale locale;\n  final MCalThemeData theme;\n  final Widget Function(BuildContext, MCalDayHeaderContext)? dayHeaderBuilder;\n  final VoidCallback? onTap;\n  final VoidCallback? onLongPress;\n  final TextDirection textDirection;\n  \n  @override\n  Widget build(BuildContext context) {\n    final weekNumber = _calculateISOWeekNumber(displayDate);\n    \n    final headerContext = MCalDayHeaderContext(\n      date: displayDate,\n      weekNumber: weekNumber,\n      isToday: _isToday(displayDate),\n    );\n    \n    // Custom builder takes precedence\n    if (dayHeaderBuilder != null) {\n      return _wrapWithGestureDetector(\n        dayHeaderBuilder!(context, headerContext),\n      );\n    }\n    \n    // Default header layout\n    return _wrapWithGestureDetector(\n      Positioned(\n        top: 8,\n        left: textDirection == TextDirection.ltr ? 8 : null,\n        right: textDirection == TextDirection.rtl ? 8 : null,\n        child: Row(\n          mainAxisSize: MainAxisSize.min,\n          children: [\n            // Week number (optional, left for LTR, right for RTL)\n            if (showWeekNumber && textDirection == TextDirection.ltr) ...[\n              _buildWeekNumber(weekNumber),\n              const SizedBox(width: 8),\n            ],\n            \n            // Day of week and date\n            _buildDayAndDate(),\n            \n            // Week number (optional, right for RTL)\n            if (showWeekNumber && textDirection == TextDirection.rtl) ...[\n              const SizedBox(width: 8),\n              _buildWeekNumber(weekNumber),\n            ],\n          ],\n        ),\n      ),\n    );\n  }\n  \n  Widget _buildWeekNumber(int weekNumber) {\n    return Container(\n      padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),\n      decoration: BoxDecoration(\n        color: theme.weekNumberBackgroundColor ?? \n               Colors.grey.withValues(alpha: 0.2),\n        borderRadius: BorderRadius.circular(4),\n      ),\n      child: Text(\n        'W$weekNumber',\n        style: theme.weekNumberTextStyle ?? TextStyle(\n          fontSize: 11,\n          fontWeight: FontWeight.w500,\n          color: theme.weekNumberTextColor ?? Colors.black54,\n        ),\n      ),\n    );\n  }\n  \n  Widget _buildDayAndDate() {\n    final dayOfWeek = DateFormat('EEE', locale.toString()).format(displayDate);\n    final dateNum = displayDate.day;\n    \n    return Column(\n      crossAxisAlignment: CrossAxisAlignment.start,\n      mainAxisSize: MainAxisSize.min,\n      children: [\n        Text(\n          dayOfWeek.toUpperCase(),\n          style: theme.dayHeaderDayOfWeekStyle ?? TextStyle(\n            fontSize: 12,\n            fontWeight: FontWeight.w500,\n            color: Colors.grey[600],\n          ),\n        ),\n        Text(\n          dateNum.toString(),\n          style: theme.dayHeaderDateStyle ?? TextStyle(\n            fontSize: 24,\n            fontWeight: FontWeight.bold,\n            color: Colors.black87,\n          ),\n        ),\n      ],\n    );\n  }\n  \n  Widget _wrapWithGestureDetector(Widget child) {\n    if (onTap == null && onLongPress == null) return child;\n    \n    return GestureDetector(\n      onTap: onTap,\n      onLongPress: onLongPress,\n      child: child,\n    );\n  }\n  \n  /// Calculates ISO 8601 week number.\n  /// Week 1 is the week with the first Thursday of the year.\n  int _calculateISOWeekNumber(DateTime date) {\n    // ISO 8601 week date calculation\n    final dayOfYear = _dayOfYear(date);\n    final weekDay = date.weekday;\n    \n    // Find Thursday of current week\n    final thursday = date.add(Duration(days: 4 - weekDay));\n    \n    // Week 1 is the week containing the first Thursday\n    final jan4 = DateTime(thursday.year, 1, 4);\n    final jan4Thursday = jan4.add(Duration(days: 4 - jan4.weekday));\n    \n    final weekNumber = 1 + ((thursday.difference(jan4Thursday).inDays) / 7).floor();\n    return weekNumber;\n  }\n  \n  int _dayOfYear(DateTime date) {\n    final startOfYear = DateTime(date.year, 1, 1);\n    return date.difference(startOfYear).inDays + 1;\n  }\n  \n  bool _isToday(DateTime date) {\n    final now = DateTime.now();\n    return date.year == now.year && \n           date.month == now.month && \n           date.day == now.day;\n  }\n}\n```\n\n**Features:**\n- **Day of week**: 3-letter abbreviation (e.g., \"FRI\")\n- **Date number**: Day of month (e.g., \"13\")\n- **Optional week number** (NEW - inspired by Kalender): ISO 8601 week number (e.g., \"W7\")\n- **RTL support**: Layout mirrors for RTL languages\n- **Tap/LongPress**: Invokes `onDayHeaderTap`/`onDayHeaderLongPress` callbacks\n- **Custom builder**: Full override via `dayHeaderBuilder`\n\n**Dependencies:** Theme, `intl` for date formatting\n\n**Reuses:** Date formatting pattern from month view, GestureDetector wrapping pattern\n\n### Component 5: Time Legend Column\n\n**Purpose:** Renders hour labels along the left (LTR) or right (RTL) edge.\n\n**Widget:** `_TimeLegendColumn` (private StatelessWidget)\n\n**Design:**\n```dart\nclass _TimeLegendColumn extends StatelessWidget {\n  final int startHour;\n  final int endHour;\n  final double hourHeight;\n  final String? timeLabelFormat;\n  final Widget Function(BuildContext, MCalTimeLabelContext)? timeLabelBuilder;\n  final MCalThemeData theme;\n  final Locale locale;\n  final VoidCallback? onTimeLabelTap;\n  \n  @override\n  Widget build(BuildContext context) {\n    final totalHours = endHour - startHour + 1;\n    final columnHeight = hourHeight * totalHours;\n    \n    return Container(\n      width: theme.timeLegendWidth ?? 60.0,\n      height: columnHeight,\n      color: theme.timeLegendBackgroundColor,\n      child: Stack(\n        children: [\n          for (int hour = startHour; hour <= endHour; hour++)\n            Positioned(\n              top: (hour - startHour) * hourHeight,\n              left: 0,\n              right: 0,\n              child: _buildHourLabel(hour),\n            ),\n        ],\n      ),\n    );\n  }\n  \n  Widget _buildHourLabel(int hour) {\n    final time = DateTime(2000, 1, 1, hour, 0);  // Date irrelevant\n    final context = MCalTimeLabelContext(\n      hour: hour,\n      time: time,\n      locale: locale,\n    );\n    \n    if (timeLabelBuilder != null) {\n      return timeLabelBuilder!(context, context);\n    }\n    \n    // Default: format using locale\n    final format = timeLabelFormat ?? (locale.languageCode == 'en' ? 'h a' : 'HH:mm');\n    final label = DateFormat(format, locale.toString()).format(time);\n    \n    return GestureDetector(\n      onTap: onTimeLabelTap,\n      child: Center(\n        child: Text(\n          label,\n          style: theme.timeLegendTextStyle,\n        ),\n      ),\n    );\n  }\n}\n```\n\n**Dependencies:** intl `DateFormat`, theme\n\n**Reuses:** Locale detection pattern from month view\n\n### Component 5: Gridlines Layer with Configurable Intervals\n\n**Purpose:** Renders horizontal lines at configurable intervals (1, 5, 10, 15, 20, 30, or 60 minutes).\n\n**Widget:** `_GridlinesLayer` (private StatelessWidget in Stack)\n\n**Design:**\n```dart\nenum MCalGridlineType {\n  /// Primary hour gridline (e.g., 9:00, 10:00).\n  hour,\n  /// Major subdivision (e.g., 30-minute intervals).\n  major,\n  /// Minor subdivision (e.g., 15-minute intervals).\n  minor,\n}\n\nclass _GridlinesLayer extends StatelessWidget {\n  final int startHour;\n  final int endHour;\n  final double hourHeight;\n  final Duration gridlineInterval;  // 1, 5, 10, 15, 20, 30, or 60 minutes\n  final MCalThemeData theme;\n  final Widget Function(BuildContext, MCalGridlineContext)? gridlineBuilder;\n  \n  @override\n  Widget build(BuildContext context) {\n    final totalHours = endHour - startHour + 1;\n    final height = hourHeight * totalHours;\n    final totalMinutes = totalHours * 60;\n    final intervalMinutes = gridlineInterval.inMinutes;\n    \n    return SizedBox(\n      height: height,\n      child: Stack(\n        children: [\n          // Generate gridlines at specified interval\n          for (int minuteOffset = 0; minuteOffset <= totalMinutes; minuteOffset += intervalMinutes)\n            _buildGridline(\n              minuteOffset: minuteOffset,\n              totalMinutes: totalMinutes,\n            ),\n        ],\n      ),\n    );\n  }\n  \n  Widget _buildGridline({\n    required int minuteOffset,\n    required int totalMinutes,\n  }) {\n    final offset = (minuteOffset / 60.0) * hourHeight;\n    final hour = startHour + (minuteOffset ~/ 60);\n    final minute = minuteOffset % 60;\n    \n    // Determine gridline type\n    final gridlineType = _determineGridlineType(minute);\n    \n    final gridlineContext = MCalGridlineContext(\n      hour: hour,\n      minute: minute,\n      offset: offset,\n      type: gridlineType,\n      intervalMinutes: gridlineInterval.inMinutes,\n    );\n    \n    if (gridlineBuilder != null) {\n      return Positioned(\n        top: offset,\n        left: 0,\n        right: 0,\n        child: gridlineBuilder!(context, gridlineContext),\n      );\n    }\n    \n    // Default gridline\n    final (color, width) = _getDefaultGridlineStyle(gridlineType);\n      \n    return Positioned(\n      top: offset,\n      left: 0,\n      right: 0,\n      child: Container(\n        height: width,\n        color: color,\n      ),\n    );\n  }\n  \n  MCalGridlineType _determineGridlineType(int minute) {\n    if (minute == 0) return MCalGridlineType.hour;\n    if (minute == 30 && gridlineInterval.inMinutes <= 30) {\n      return MCalGridlineType.major;\n    }\n    return MCalGridlineType.minor;\n  }\n  \n  (Color, double) _getDefaultGridlineStyle(MCalGridlineType type) {\n    switch (type) {\n      case MCalGridlineType.hour:\n        return (\n          theme.hourGridlineColor ?? Colors.grey.withValues(alpha: 0.2),\n          theme.hourGridlineWidth ?? 1.0,\n        );\n      case MCalGridlineType.major:\n        return (\n          theme.majorGridlineColor ?? Colors.grey.withValues(alpha: 0.15),\n          theme.majorGridlineWidth ?? 1.0,\n        );\n      case MCalGridlineType.minor:\n        return (\n          theme.minorGridlineColor ?? Colors.grey.withValues(alpha: 0.08),\n          theme.minorGridlineWidth ?? 0.5,\n        );\n    }\n  }\n}\n```\n\n**Dependencies:** Theme\n\n**Reuses:** `Positioned` layout pattern from month view week rows\n\n**Configuration:** Developer sets `gridlineInterval: Duration(minutes: 15)` and all gridlines at 15-minute intervals are rendered. Builder receives full context to customize each type.\n\n### Component 5a: Special Time Regions Layer (NEW)\n\n**Purpose:** Renders special time regions with custom styling and optional interaction blocking.\n\n**Inspiration:** Adapted from:\n- Month view's blockout days pattern (`onDragWillAccept` validation + `dayCellBuilder` styling)\n- Syncfusion's `TimeRegion` with visual customization and pointer interaction control\n- Kalender's customizable time indicators\n\n**Widget:** `_TimeRegionsLayer` (private StatelessWidget in Stack, rendered between gridlines and events)\n\n**Design:**\n```dart\nclass _TimeRegionsLayer extends StatelessWidget {\n  final List<MCalTimeRegion> regions;\n  final DateTime displayDate;\n  final int startHour;\n  final int endHour;\n  final double hourHeight;\n  final MCalThemeData theme;\n  final Widget Function(BuildContext, MCalTimeRegionContext)? timeRegionBuilder;\n  \n  @override\n  Widget build(BuildContext context) {\n    // Filter regions to only those that apply to displayDate\n    final applicableRegions = _getApplicableRegions();\n    \n    return Stack(\n      children: [\n        for (final region in applicableRegions)\n          _buildTimeRegion(context, region),\n      ],\n    );\n  }\n  \n  List<MCalTimeRegion> _getApplicableRegions() {\n    final result = <MCalTimeRegion>[];\n    \n    for (final region in regions) {\n      // Check if region applies to displayDate\n      if (_regionAppliesToDate(region, displayDate)) {\n        result.add(region);\n      }\n      \n      // If region has recurrence rule, expand occurrences\n      if (region.recurrenceRule != null) {\n        // Use existing recurrence expansion logic from controller\n        final occurrences = _expandRecurringRegion(region, displayDate);\n        result.addAll(occurrences);\n      }\n    }\n    \n    return result;\n  }\n  \n  Widget _buildTimeRegion(BuildContext context, MCalTimeRegion region) {\n    // Calculate vertical position and height\n    final startOffset = _timeToOffset(region.startTime);\n    final endOffset = _timeToOffset(region.endTime);\n    final height = endOffset - startOffset;\n    \n    final regionContext = MCalTimeRegionContext(\n      region: region,\n      displayDate: displayDate,\n      startOffset: startOffset,\n      height: height,\n    );\n    \n    // Custom builder takes precedence\n    if (timeRegionBuilder != null) {\n      return Positioned(\n        top: startOffset,\n        left: 0,\n        right: 0,\n        height: height,\n        child: timeRegionBuilder!(context, regionContext),\n      );\n    }\n    \n    // Default region appearance (similar to month view blockout styling)\n    return Positioned(\n      top: startOffset,\n      left: 0,\n      right: 0,\n      height: height,\n      child: Container(\n        decoration: BoxDecoration(\n          color: region.color ?? \n                 (region.blockInteraction \n                   ? theme.blockedTimeRegionColor \n                   : theme.specialTimeRegionColor),\n          border: Border(\n            top: BorderSide(\n              color: theme.timeRegionBorderColor ?? Colors.grey.withValues(alpha: 0.3),\n              width: 1,\n            ),\n            bottom: BorderSide(\n              color: theme.timeRegionBorderColor ?? Colors.grey.withValues(alpha: 0.3),\n              width: 1,\n            ),\n          ),\n        ),\n        child: region.text != null || region.icon != null\n          ? Center(\n              child: Row(\n                mainAxisSize: MainAxisSize.min,\n                children: [\n                  if (region.icon != null) ...[\n                    Icon(\n                      region.icon,\n                      size: 16,\n                      color: theme.timeRegionTextColor ?? Colors.black54,\n                    ),\n                    if (region.text != null) const SizedBox(width: 4),\n                  ],\n                  if (region.text != null)\n                    Text(\n                      region.text!,\n                      style: TextStyle(\n                        fontSize: 12,\n                        color: theme.timeRegionTextColor ?? Colors.black54,\n                      ),\n                    ),\n                ],\n              ),\n            )\n          : null,\n      ),\n    );\n  }\n  \n  double _timeToOffset(DateTime time) {\n    final hour = time.hour;\n    final minute = time.minute;\n    final totalMinutes = (hour - startHour) * 60 + minute;\n    return (totalMinutes / 60.0) * hourHeight;\n  }\n  \n  bool _regionAppliesToDate(MCalTimeRegion region, DateTime date) {\n    // Check if region's date matches displayDate\n    return region.startTime.year == date.year &&\n           region.startTime.month == date.month &&\n           region.startTime.day == date.day;\n  }\n  \n  List<MCalTimeRegion> _expandRecurringRegion(\n    MCalTimeRegion region, \n    DateTime date,\n  ) {\n    // Reuse event controller's recurrence expansion logic\n    // Generate occurrences for the display date\n    // Return list of MCalTimeRegion instances for each occurrence\n    // Implementation similar to event recurrence expansion\n    return [];  // Placeholder\n  }\n}\n```\n\n**Dependencies:** Theme, recurrence expansion utilities\n\n**Integration with Drag Operations:**\n- Regions with `blockInteraction: true` are validated in `onDragWillAccept` callback\n- Similar to month view's blockout dates that reject drops\n- Validation checks if proposed event time range overlaps any blocked region\n\n**Use Cases:**\n1. **Non-working hours:** Mark 6pm-8am as blocked (gray overlay)\n2. **Lunch breaks:** Daily 12pm-1pm recurring region (visual indicator)\n3. **Meeting-free zones:** 9am-10am focus time (block drops)\n4. **Weekends/holidays:** Entire day as special region\n5. **Custom business rules:** Any time-based restriction\n\n**Reuses:** `Positioned` layout pattern, recurrence expansion from event controller\n\n### Component 6: All-Day Events Section\n\n**Purpose:** Displays all-day events horizontally with overflow handling, drag source, and resize handles.\n\n**Widget:** `_AllDayEventsSection` (private StatefulWidget)\n\n**Design:**\n```dart\nclass _AllDayEventsSection extends StatefulWidget {\n  final List<MCalCalendarEvent> allDayEvents;\n  final int maxRows;\n  final MCalThemeData theme;\n  final Widget Function(BuildContext, MCalEventTileContext, Widget)? tileBuilder;\n  final bool enableDragToMove;\n  final bool enableDragToResize;\n  final Function(MCalCalendarEvent)? onEventTap;\n  final Function(MCalCalendarEvent)? onEventLongPress;\n  final VoidCallback? onOverflowTap;\n  \n  @override\n  State<_AllDayEventsSection> createState() => _AllDayEventsSectionState();\n}\n\nclass _AllDayEventsSectionState extends State<_AllDayEventsSection> {\n  @override\n  Widget build(BuildContext context) {\n    final visibleEvents = widget.allDayEvents.take(widget.maxRows * 2).toList();\n    final hasOverflow = widget.allDayEvents.length > visibleEvents.length;\n    \n    return Container(\n      constraints: BoxConstraints(\n        maxHeight: widget.theme.allDaySectionHeight \n          ?? (widget.maxRows * (theme.eventTileHeight + 4.0)),\n      ),\n      child: Column(\n        mainAxisSize: MainAxisSize.min,\n        children: [\n          Wrap(\n            children: [\n              for (final event in visibleEvents)\n                _buildAllDayTile(event),\n            ],\n          ),\n          if (hasOverflow)\n            _buildOverflowIndicator(widget.allDayEvents.length - visibleEvents.length),\n        ],\n      ),\n    );\n  }\n  \n  Widget _buildAllDayTile(MCalCalendarEvent event) {\n    final tileContext = MCalEventTileContext(\n      event: event,\n      displayDate: widget.displayDate,\n      isAllDay: true,\n      // ... other context fields\n    );\n    \n    Widget tile = Container(\n      height: theme.eventTileHeight,\n      padding: theme.eventTilePadding,\n      decoration: BoxDecoration(\n        color: event.color ?? theme.allDayEventBackgroundColor,\n        borderRadius: BorderRadius.circular(theme.eventTileCornerRadius ?? 4.0),\n      ),\n      child: Text(event.title, style: theme.allDayEventTextStyle),\n    );\n    \n    if (widget.tileBuilder != null) {\n      tile = widget.tileBuilder!(context, tileContext, tile);\n    }\n    \n    // Wrap in draggable if enabled\n    if (widget.enableDragToMove) {\n      tile = MCalDraggableEventTile(\n        event: event,\n        child: tile,\n        // ... drag configuration\n      );\n    }\n    \n    // Add resize handles if enabled\n    if (widget.enableDragToResize && _shouldShowResizeHandles(event)) {\n      tile = _wrapWithResizeHandles(tile, event, tileContext);\n    }\n    \n    return GestureDetector(\n      onTap: () => widget.onEventTap?.call(event),\n      onLongPress: () => widget.onEventLongPress?.call(event),\n      child: tile,\n    );\n  }\n}\n```\n\n**Dependencies:** `MCalDraggableEventTile`, theme\n\n**Reuses:** Month view's multi-day tile rendering pattern, drag infrastructure\n\n### Component 7: Timed Events Layer with Overlap Layout\n\n**Purpose:** Renders timed events with automatic column layout for overlaps.\n\n**Widget:** `_TimedEventsLayer` (private StatelessWidget in Stack)\n\n**Design:**\n```dart\nclass _TimedEventsLayer extends StatelessWidget {\n  final List<MCalCalendarEvent> timedEvents;\n  final DateTime displayDate;\n  final int startHour;\n  final int endHour;\n  final double hourHeight;\n  final Duration timeSlotDuration;\n  final double areaWidth;\n  final MCalThemeData theme;\n  final Widget Function(BuildContext, MCalTimedEventTileContext, Widget)? tileBuilder;\n  final MCalDayLayoutBuilder? dayLayoutBuilder;\n  final bool enableDragToMove;\n  final bool enableDragToResize;\n  \n  @override\n  Widget build(BuildContext context) {\n    final totalHeight = hourHeight * (endHour - startHour + 1);\n    \n    // Use custom layout builder if provided\n    if (dayLayoutBuilder != null) {\n      return SizedBox(\n        height: totalHeight,\n        child: dayLayoutBuilder!(context, MCalDayLayoutContext(\n          events: timedEvents,\n          displayDate: displayDate,\n          startHour: startHour,\n          endHour: endHour,\n          hourHeight: hourHeight,\n          areaWidth: areaWidth,\n        )),\n      );\n    }\n    \n    // Default: overlap detection + column layout\n    final overlapGroup = detectOverlapsAndAssignColumns(timedEvents);\n    \n    return SizedBox(\n      height: totalHeight,\n      child: Stack(\n        children: [\n          for (int i = 0; i < overlapGroup.events.length; i++)\n            _buildPositionedEvent(\n              overlapGroup.events[i],\n              overlapGroup.columnAssignments[i],\n              overlapGroup.totalColumns,\n            ),\n        ],\n      ),\n    );\n  }\n  \n  Widget _buildPositionedEvent(\n    MCalCalendarEvent event,\n    int columnIndex,\n    int totalColumns,\n  ) {\n    // Calculate position and size\n    final topOffset = timeToOffset(\n      time: event.start,\n      startHour: startHour,\n      hourHeight: hourHeight,\n    );\n    \n    final height = durationToHeight(\n      duration: event.end.difference(event.start),\n      hourHeight: hourHeight,\n    ).clamp(theme.timedEventMinHeight ?? 20.0, double.infinity);\n    \n    final columnWidth = areaWidth / totalColumns;\n    final leftOffset = columnIndex * columnWidth;\n    \n    final tileContext = MCalTimedEventTileContext(\n      event: event,\n      displayDate: displayDate,\n      columnIndex: columnIndex,\n      totalColumns: totalColumns,\n      startTime: event.start,\n      endTime: event.end,\n    );\n    \n    Widget tile = _buildEventTile(event, tileContext);\n    \n    // Add resize handles if enabled\n    if (enableDragToResize) {\n      tile = _wrapWithResizeHandles(tile, event, tileContext);\n    }\n    \n    return Positioned(\n      top: topOffset,\n      left: leftOffset,\n      width: columnWidth,\n      height: height,\n      child: tile,\n    );\n  }\n}\n```\n\n**Dependencies:** Overlap detection algorithm, time utilities, `MCalDraggableEventTile`\n\n**Reuses:** Month view event tile rendering patterns, drag infrastructure\n\n### Component 8: Current Time Indicator\n\n**Purpose:** Displays horizontal line at current time with automatic updates.\n\n**Widget:** `_CurrentTimeIndicator` (private StatefulWidget)\n\n**Design:**\n```dart\nclass _CurrentTimeIndicator extends StatefulWidget {\n  final int startHour;\n  final double hourHeight;\n  final bool isRTL;\n  final MCalThemeData theme;\n  final Widget Function(BuildContext, MCalCurrentTimeContext)? builder;\n  \n  @override\n  State<_CurrentTimeIndicator> createState() => _CurrentTimeIndicatorState();\n}\n\nclass _CurrentTimeIndicatorState extends State<_CurrentTimeIndicator> {\n  Timer? _timer;\n  DateTime _currentTime = DateTime.now();\n  \n  @override\n  void initState() {\n    super.initState();\n    _startTimer();\n  }\n  \n  void _startTimer() {\n    // Update every minute\n    _timer = Timer.periodic(const Duration(minutes: 1), (_) {\n      if (mounted) {\n        setState(() {\n          _currentTime = DateTime.now();\n        });\n      }\n    });\n  }\n  \n  @override\n  void dispose() {\n    _timer?.cancel();\n    super.dispose();\n  }\n  \n  @override\n  Widget build(BuildContext context) {\n    final offset = timeToOffset(\n      time: _currentTime,\n      startHour: widget.startHour,\n      hourHeight: widget.hourHeight,\n    );\n    \n    final indicatorContext = MCalCurrentTimeContext(\n      currentTime: _currentTime,\n      offset: offset,\n      isRTL: widget.isRTL,\n    );\n    \n    if (widget.builder != null) {\n      return Positioned(\n        top: offset,\n        left: 0,\n        right: 0,\n        child: widget.builder!(context, indicatorContext),\n      );\n    }\n    \n    // Default indicator\n    return Positioned(\n      top: offset,\n      left: 0,\n      right: 0,\n      child: Row(\n        children: [\n          if (!widget.isRTL) _buildDot(),\n          Expanded(\n            child: Container(\n              height: widget.theme.currentTimeIndicatorWidth ?? 2.0,\n              color: widget.theme.currentTimeIndicatorColor ?? Colors.red,\n            ),\n          ),\n          if (widget.isRTL) _buildDot(),\n        ],\n      ),\n    );\n  }\n  \n  Widget _buildDot() {\n    return Container(\n      width: (widget.theme.currentTimeIndicatorDotRadius ?? 6.0) * 2,\n      height: (widget.theme.currentTimeIndicatorDotRadius ?? 6.0) * 2,\n      decoration: BoxDecoration(\n        shape: BoxShape.circle,\n        color: widget.theme.currentTimeIndicatorColor ?? Colors.red,\n      ),\n    );\n  }\n}\n```\n\n**Dependencies:** Theme, time utilities, `Timer`\n\n**Reuses:** `Positioned` layout, theme pattern\n\n### Component 8a: Empty Time Slot Gesture Handling (NEW)\n\n**Purpose:** Detects taps and long presses on empty time slots for event creation or custom actions.\n\n**Inspiration:** Adapted from month view's `onCellTap`/`onCellLongPress` pattern for empty cells.\n\n**Integration:** Wraps the Stack (5 layers) with `GestureDetector` in the scrollable area.\n\n**Design:**\n```dart\n// In _MCalDayViewState build method, wrapping the timed events Stack\n\nWidget _buildTimedEventsArea() {\n  return GestureDetector(\n    behavior: HitTestBehavior.translucent,  // Detect taps on empty space\n    onTapUp: (details) => _handleTimeSlotTap(details.localPosition),\n    onLongPressStart: (details) => _handleTimeSlotLongPress(details.localPosition),\n    child: Stack(\n      children: [\n        _GridlinesLayer(...),\n        _TimeRegionsLayer(...),\n        _TimedEventsLayer(...),\n        _CurrentTimeIndicator(...),\n        _DropTargetPreviewLayer(...),\n        _DropTargetOverlayLayer(...),\n      ],\n    ),\n  );\n}\n\nvoid _handleTimeSlotTap(Offset localPosition) {\n  if (widget.onTimeSlotTap == null) return;\n  \n  // Convert Y position to DateTime\n  final tappedTime = offsetToTime(\n    offset: localPosition.dy,\n    date: _displayDate,\n    startHour: widget.startHour,\n    hourHeight: _cachedHourHeight,\n    timeSlotDuration: widget.timeSlotDuration,\n  );\n  \n  // Check if tap hit an event (in which case, event tap takes precedence)\n  if (_didTapHitEvent(localPosition)) return;\n  \n  // Create context for callback\n  final context = MCalTimeSlotContext(\n    time: tappedTime,\n    date: _displayDate,\n    offset: localPosition,\n  );\n  \n  widget.onTimeSlotTap!(this.context, context);\n}\n\nvoid _handleTimeSlotLongPress(Offset localPosition) {\n  if (widget.onTimeSlotLongPress == null) return;\n  \n  final tappedTime = offsetToTime(\n    offset: localPosition.dy,\n    date: _displayDate,\n    startHour: widget.startHour,\n    hourHeight: _cachedHourHeight,\n    timeSlotDuration: widget.timeSlotDuration,\n  );\n  \n  if (_didTapHitEvent(localPosition)) return;\n  \n  final context = MCalTimeSlotContext(\n    time: tappedTime,\n    date: _displayDate,\n    offset: localPosition,\n  );\n  \n  widget.onTimeSlotLongPress!(this.context, context);\n}\n\n/// Checks if the tap position overlaps with any event tile.\n/// Events absorb taps via their own GestureDetectors.\nbool _didTapHitEvent(Offset localPosition) {\n  // Check if position overlaps any rendered event\n  // Events have their own GestureDetectors which will consume the tap\n  // This is a fallback check for edge cases\n  for (final event in _timedEvents) {\n    final topOffset = timeToOffset(\n      time: event.start,\n      startHour: widget.startHour,\n      hourHeight: _cachedHourHeight,\n    );\n    final height = durationToHeight(\n      duration: event.end.difference(event.start),\n      hourHeight: _cachedHourHeight,\n    );\n    \n    if (localPosition.dy >= topOffset && localPosition.dy <= topOffset + height) {\n      // Further check X position if needed for column layout\n      return true;\n    }\n  }\n  return false;\n}\n```\n\n**Context Object:**\n```dart\nclass MCalTimeSlotContext {\n  /// The time corresponding to the tap position (snapped to timeSlotDuration).\n  final DateTime time;\n  \n  /// The display date.\n  final DateTime date;\n  \n  /// Local offset where the tap occurred.\n  final Offset offset;\n  \n  const MCalTimeSlotContext({\n    required this.time,\n    required this.date,\n    required this.offset,\n  });\n}\n```\n\n**Use Cases:**\n- **Event creation**: Long-press to create new event at tapped time\n- **Quick actions**: Tap to show time slot details or context menu\n- **Custom interactions**: Developer-defined behavior via callbacks\n- **Analytics**: Track which time slots users interact with\n\n**Comparison to Month View:**\n- Month view: `onCellTap(context, MCalCellContext)` for empty day cells\n- Day view: `onTimeSlotTap(context, MCalTimeSlotContext)` for empty time slots\n- Both: GestureDetector with `HitTestBehavior.translucent` to detect empty space taps\n- Both: Event taps take precedence over empty space taps\n\n**Dependencies:** Time conversion utilities, gesture detection\n\n**Reuses:** Month view's empty cell tap pattern, GestureDetector wrapping\n\n### Component 9: Drag-to-Move Integration\n\n**Purpose:** Handles vertical drag within day and horizontal edge navigation for cross-day moves.\n\n**Location:** Methods in `_MCalDayViewState`\n\n**Design:**\n```dart\n// In _MCalDayViewState\n\nMCalDragHandler? _dragHandler;\nMCalDragHandler get _ensureDragHandler {\n  return _dragHandler ??= MCalDragHandler();\n}\n\nvoid _handleDragStarted(MCalCalendarEvent event, Offset localPosition) {\n  _dragHandler?.startDrag(event, event.start);\n  setState(() {\n    _isDragActive = true;\n  });\n}\n\nvoid _handleDragUpdate(DragUpdateDetails details) {\n  if (_dragHandler == null || !_dragHandler!.isDragging) return;\n  \n  final RenderBox? renderBox = _timedEventsAreaKey.currentContext?.findRenderObject() as RenderBox?;\n  if (renderBox == null) return;\n  \n  final localPosition = renderBox.globalToLocal(details.globalPosition);\n  \n  // Check for section boundary crossing (all-day ↔ timed conversion)\n  final isInAllDaySection = localPosition.dy < 0;  // Negative = above timed area\n  \n  if (isInAllDaySection && !_dragHandler!.draggedEvent!.isAllDay) {\n    // Converting timed → all-day\n    _handleTimedToAllDayConversion(localPosition);\n  } else if (!isInAllDaySection && _dragHandler!.draggedEvent!.isAllDay) {\n    // Converting all-day → timed\n    _handleAllDayToTimedConversion(localPosition);\n  } else {\n    // Same type: calculate new time/date\n    _handleSameTypeMove(localPosition);\n  }\n  \n  // Check horizontal edge proximity for day navigation\n  if (widget.dragEdgeNavigationEnabled) {\n    _checkHorizontalEdgeProximity(localPosition.dx);\n  }\n}\n\nvoid _handleTimedToAllDayConversion(Offset localPosition) {\n  // Use current displayed date (accounting for edge navigation)\n  final proposedStart = DateTime(_displayDate.year, _displayDate.month, _displayDate.day, 0, 0);\n  final proposedEnd = DateTime(_displayDate.year, _displayDate.month, _displayDate.day, 0, 0);\n  \n  _dragHandler!.updateProposedDropRange(\n    proposedStart: proposedStart,\n    proposedEnd: proposedEnd,\n    isValid: _validateDrop(proposedStart, proposedEnd, isAllDay: true),\n  );\n}\n\nvoid _handleAllDayToTimedConversion(Offset localPosition) {\n  // Calculate time from Y position\n  final proposedStartTime = offsetToTime(\n    offset: localPosition.dy,\n    date: _displayDate,\n    startHour: widget.startHour,\n    hourHeight: _cachedHourHeight,\n    timeSlotDuration: widget.timeSlotDuration,\n  );\n  \n  final proposedEndTime = proposedStartTime.add(widget.allDayToTimedDuration);\n  \n  _dragHandler!.updateProposedDropRange(\n    proposedStart: proposedStartTime,\n    proposedEnd: proposedEndTime,\n    isValid: _validateDrop(proposedStartTime, proposedEndTime, isAllDay: false),\n  );\n}\n\nvoid _handleSameTypeMove(Offset localPosition) {\n  final originalEvent = _dragHandler!.draggedEvent!;\n  final duration = originalEvent.end.difference(originalEvent.start);\n  \n  // Calculate new start time from Y position\n  var proposedStart = offsetToTime(\n    offset: localPosition.dy,\n    date: _displayDate,\n    startHour: widget.startHour,\n    hourHeight: _cachedHourHeight,\n    timeSlotDuration: widget.timeSlotDuration,\n  );\n  \n  // Apply snapping (NEW - inspired by Kalender)\n  proposedStart = _applySnapping(proposedStart, originalEvent);\n  \n  final proposedEnd = proposedStart.add(duration);\n  \n  _dragHandler!.updateProposedDropRange(\n    proposedStart: proposedStart,\n    proposedEnd: proposedEnd,\n    isValid: _validateDrop(proposedStart, proposedEnd, isAllDay: originalEvent.isAllDay),\n  );\n}\n\n/// Applies snapping logic to proposed time (NEW).\n/// \n/// Snapping priority:\n/// 1. Snap to time slots (15-minute intervals)\n/// 2. Snap to other nearby events (magnetic snapping)\n/// 3. Snap to current time indicator\nDateTime _applySnapping(DateTime proposedTime, MCalCalendarEvent draggedEvent) {\n  var snappedTime = proposedTime;\n  \n  // 1. Snap to time slots (always applied if enabled)\n  if (widget.snapToTimeSlots) {\n    snappedTime = snapToTimeSlot(\n      time: snappedTime,\n      timeSlotDuration: widget.timeSlotDuration,\n    );\n  }\n  \n  // 2. Snap to other events (magnetic snapping within snapRange)\n  if (widget.snapToOtherEvents) {\n    final nearbyEventTime = _findNearbyEventBoundary(snappedTime, draggedEvent);\n    if (nearbyEventTime != null) {\n      final difference = nearbyEventTime.difference(snappedTime).abs();\n      if (difference <= widget.snapRange) {\n        snappedTime = nearbyEventTime;\n      }\n    }\n  }\n  \n  // 3. Snap to current time indicator\n  if (widget.snapToCurrentTime && _isToday(_displayDate)) {\n    final now = DateTime.now();\n    final nowSnapped = snapToTimeSlot(\n      time: now,\n      timeSlotDuration: widget.timeSlotDuration,\n    );\n    final difference = nowSnapped.difference(snappedTime).abs();\n    if (difference <= widget.snapRange) {\n      snappedTime = nowSnapped;\n    }\n  }\n  \n  return snappedTime;\n}\n\n/// Finds the nearest event boundary (start or end) within snapRange.\nDateTime? _findNearbyEventBoundary(DateTime proposedTime, MCalCalendarEvent draggedEvent) {\n  DateTime? nearestBoundary;\n  Duration minDistance = widget.snapRange;\n  \n  for (final event in _timedEvents) {\n    // Skip the dragged event itself\n    if (event.id == draggedEvent.id) continue;\n    \n    // Check event start time\n    final startDiff = event.start.difference(proposedTime).abs();\n    if (startDiff < minDistance) {\n      minDistance = startDiff;\n      nearestBoundary = event.start;\n    }\n    \n    // Check event end time\n    final endDiff = event.end.difference(proposedTime).abs();\n    if (endDiff < minDistance) {\n      minDistance = endDiff;\n      nearestBoundary = event.end;\n    }\n  }\n  \n  return nearestBoundary;\n}\n\n/// Validates proposed drop location (NEW - enhanced with time region validation).\n/// \n/// Similar to month view's onDragWillAccept pattern for blockout dates.\n/// Checks:\n/// 1. User-provided onDragWillAccept callback\n/// 2. Blocked time regions (regions with blockInteraction: true)\n/// 3. Date boundaries (minDate/maxDate)\nbool _validateDrop(DateTime proposedStart, DateTime proposedEnd, {required bool isAllDay}) {\n  // 1. Check user callback (if provided)\n  if (widget.onDragWillAccept != null) {\n    final details = MCalEventDragWillAcceptDetails(\n      event: _dragHandler!.draggedEvent!,\n      proposedStartDate: proposedStart,\n      proposedEndDate: proposedEnd,\n      isAllDay: isAllDay,\n    );\n    if (!widget.onDragWillAccept!(context, details)) {\n      return false;\n    }\n  }\n  \n  // 2. Check blocked time regions (NEW - inspired by Syncfusion special regions)\n  if (!isAllDay) {\n    for (final region in widget.specialTimeRegions) {\n      if (region.blockInteraction && region.overlaps(proposedStart, proposedEnd)) {\n        return false;  // Reject drop into blocked region\n      }\n      \n      // Check recurring regions\n      if (region.recurrenceRule != null) {\n        final occurrences = _expandTimeRegionForDate(region, proposedStart);\n        for (final occurrence in occurrences) {\n          if (occurrence.blockInteraction && occurrence.overlaps(proposedStart, proposedEnd)) {\n            return false;\n          }\n        }\n      }\n    }\n  }\n  \n  // 3. Check date boundaries\n  if (widget.minDate != null && proposedStart.isBefore(widget.minDate!)) {\n    return false;\n  }\n  if (widget.maxDate != null && proposedEnd.isAfter(widget.maxDate!)) {\n    return false;\n  }\n  \n  return true;\n}\n\n/// Expands a recurring time region for a specific date.\nList<MCalTimeRegion> _expandTimeRegionForDate(MCalTimeRegion region, DateTime date) {\n  // Reuse recurrence expansion logic from event controller\n  // Similar to how recurring events are expanded\n  // Returns list of region occurrences for the given date\n  return [];  // Placeholder - implementation similar to event recurrence\n}\n\nvoid _checkHorizontalEdgeProximity(double localX) {\n  final edgeThreshold = _cachedAreaWidth * 0.1;\n  final nearLeftEdge = localX < edgeThreshold;\n  final nearRightEdge = localX > (_cachedAreaWidth - edgeThreshold);\n  \n  if (nearLeftEdge) {\n    _dragHandler!.handleEdgeProximity(\n      isNearEdge: true,\n      isLeftEdge: true,\n      navigateCallback: _navigateToPreviousDay,\n      delay: widget.dragEdgeNavigationDelay,\n    );\n  } else if (nearRightEdge) {\n    _dragHandler!.handleEdgeProximity(\n      isNearEdge: true,\n      isLeftEdge: false,\n      navigateCallback: _navigateToNextDay,\n      delay: widget.dragEdgeNavigationDelay,\n    );\n  } else {\n    _dragHandler!.handleEdgeProximity(\n      isNearEdge: false,\n      isLeftEdge: false,\n      navigateCallback: () {},\n    );\n  }\n}\n\nvoid _handleDrop() {\n  final dragHandler = _dragHandler;\n  if (dragHandler == null || !dragHandler.isDragging) return;\n  \n  final proposedStart = dragHandler.proposedStartDate;\n  final proposedEnd = dragHandler.proposedEndDate;\n  \n  if (proposedStart == null || proposedEnd == null || !dragHandler.isProposedDropValid) {\n    dragHandler.cancelDrag();\n    setState(() => _isDragActive = false);\n    return;\n  }\n  \n  final originalEvent = dragHandler.draggedEvent!;\n  final typeChanged = originalEvent.isAllDay != _isAllDayArea(proposedStart, proposedEnd);\n  \n  // Build updated event\n  final updatedEvent = originalEvent.copyWith(\n    start: proposedStart,\n    end: proposedEnd,\n    isAllDay: _isAllDayArea(proposedStart, proposedEnd),\n  );\n  \n  // Build details\n  final details = MCalEventDroppedDetails(\n    event: originalEvent,\n    newStart: proposedStart,\n    newEnd: proposedEnd,\n    oldStart: originalEvent.start,\n    oldEnd: originalEvent.end,\n    isRecurring: originalEvent.recurrenceRule != null,\n    seriesId: originalEvent.seriesId,\n    typeConversion: typeChanged ? (originalEvent.isAllDay ? 'allDayToTimed' : 'timedToAllDay') : null,\n  );\n  \n  // Call callback\n  final accepted = widget.onEventDropped?.call(context, details) ?? true;\n  \n  if (accepted) {\n    if (originalEvent.occurrenceId != null) {\n      // Recurring: create modified exception\n      widget.controller.modifyOccurrence(\n        originalEvent.seriesId!,\n        DateTime.parse(originalEvent.occurrenceId!),\n        updatedEvent,\n      );\n    } else {\n      // Non-recurring: update event\n      widget.controller.addEvents([updatedEvent]);\n    }\n  }\n  \n  dragHandler.completeDrag();\n  setState(() => _isDragActive = false);\n}\n```\n\n**Dependencies:** `MCalDragHandler`, time utilities, controller\n\n**Reuses:** Month view `_handleDrop` flow, exception handling pattern\n\n### Component 10: Resize Integration with Time-Based Edges\n\n**Purpose:** Handles top/bottom edge resize for timed events and left/right edge resize for all-day events.\n\n**Location:** Methods in `_MCalDayViewState`\n\n**Design:**\n```dart\n// Resize handle widget\nclass _TimeResizeHandle extends StatelessWidget {\n  final MCalResizeEdge edge;  // start (top) or end (bottom)\n  final MCalCalendarEvent event;\n  final bool isAllDayEvent;\n  final double handleHeight;  // 8.0 default for timed, full width for all-day\n  final VoidCallback onResizeStart;\n  final ValueChanged<Offset> onResizeUpdate;\n  final VoidCallback onResizeEnd;\n  final VoidCallback onResizeCancel;\n  final Widget Function(BuildContext, MCalResizeHandleContext)? visualBuilder;\n  \n  @override\n  Widget build(BuildContext context) {\n    final handleContext = MCalResizeHandleContext(\n      edge: edge,\n      event: event,\n      isDropTargetPreview: false,\n    );\n    \n    Widget visual;\n    if (visualBuilder != null) {\n      visual = visualBuilder!(context, handleContext);\n    } else {\n      // Default: semi-transparent bar\n      visual = Container(\n        height: isAllDayEvent ? 2.0 : handleHeight,\n        width: isAllDayEvent ? handleHeight : double.infinity,\n        color: Colors.white.withValues(alpha: 0.5),\n      );\n    }\n    \n    return Positioned(\n      top: edge == MCalResizeEdge.start ? 0 : null,\n      bottom: edge == MCalResizeEdge.end ? 0 : null,\n      left: 0,\n      right: 0,\n      child: MouseRegion(\n        cursor: isAllDayEvent \n          ? SystemMouseCursors.resizeColumn \n          : SystemMouseCursors.resizeUpDown,\n        child: GestureDetector(\n          onPanStart: (_) => onResizeStart(),\n          onPanUpdate: (details) => onResizeUpdate(details.localPosition),\n          onPanEnd: (_) => onResizeEnd(),\n          onPanCancel: () => onResizeCancel(),\n          child: visual,\n        ),\n      ),\n    );\n  }\n}\n\n// In _MCalDayViewState\n\nvoid _handleResizeStart(MCalCalendarEvent event, MCalResizeEdge edge) {\n  _dragHandler?.startResize(event, edge);\n  setState(() => _isResizeActive = true);\n}\n\nvoid _handleResizeUpdate(Offset localPosition, MCalResizeEdge edge, bool isAllDay) {\n  if (_dragHandler == null || !_dragHandler!.isResizing) return;\n  \n  final originalEvent = _dragHandler!.resizingEvent!;\n  \n  if (isAllDay) {\n    // All-day: horizontal resize changes dates\n    _handleAllDayResize(localPosition, edge, originalEvent);\n  } else {\n    // Timed: vertical resize changes times\n    _handleTimedResize(localPosition, edge, originalEvent);\n  }\n  \n  // Check horizontal edge proximity for day navigation (both event types)\n  if (widget.dragEdgeNavigationEnabled) {\n    _checkHorizontalEdgeProximityForResize(localPosition.dx);\n  }\n}\n\nvoid _handleTimedResize(Offset localPosition, MCalResizeEdge edge, MCalCalendarEvent event) {\n  DateTime proposedStart = event.start;\n  DateTime proposedEnd = event.end;\n  \n  if (edge == MCalResizeEdge.start) {\n    // Top edge: change start time\n    proposedStart = offsetToTime(\n      offset: localPosition.dy,\n      date: _displayDate,\n      startHour: widget.startHour,\n      hourHeight: _cachedHourHeight,\n      timeSlotDuration: widget.timeSlotDuration,\n    );\n    // Enforce minimum duration\n    final minimumEnd = proposedStart.add(widget.timeSlotDuration);\n    if (proposedEnd.isBefore(minimumEnd)) {\n      proposedStart = proposedEnd.subtract(widget.timeSlotDuration);\n    }\n  } else {\n    // Bottom edge: change end time\n    proposedEnd = offsetToTime(\n      offset: localPosition.dy,\n      date: _displayDate,\n      startHour: widget.startHour,\n      hourHeight: _cachedHourHeight,\n      timeSlotDuration: widget.timeSlotDuration,\n    );\n    // Enforce minimum duration\n    final minimumEnd = proposedStart.add(widget.timeSlotDuration);\n    if (proposedEnd.isBefore(minimumEnd)) {\n      proposedEnd = minimumEnd;\n    }\n  }\n  \n  final isValid = _validateResize(event, proposedStart, proposedEnd, edge);\n  \n  _dragHandler!.updateResize(\n    proposedStart: proposedStart,\n    proposedEnd: proposedEnd,\n    isValid: isValid,\n    cells: [], // Time-based highlight, not cells\n  );\n}\n\nvoid _handleAllDayResize(Offset localPosition, MCalResizeEdge edge, MCalCalendarEvent event) {\n  // Similar to month view: horizontal position determines date delta\n  final dayDelta = (localPosition.dx / _cachedDayWidth).round();\n  \n  DateTime proposedStart = event.start;\n  DateTime proposedEnd = event.end;\n  \n  if (edge == MCalResizeEdge.start) {\n    proposedStart = DateTime(\n      _displayDate.year,\n      _displayDate.month,\n      _displayDate.day + dayDelta,\n    );\n    // Enforce minimum 1 day\n    if (!proposedStart.isBefore(proposedEnd)) {\n      proposedStart = DateTime(proposedEnd.year, proposedEnd.month, proposedEnd.day - 1);\n    }\n  } else {\n    proposedEnd = DateTime(\n      _displayDate.year,\n      _displayDate.month,\n      _displayDate.day + dayDelta,\n    );\n    // Enforce minimum 1 day\n    if (!proposedEnd.isAfter(proposedStart)) {\n      proposedEnd = DateTime(proposedStart.year, proposedStart.month, proposedStart.day + 1);\n    }\n  }\n  \n  final isValid = _validateResize(event, proposedStart, proposedEnd, edge);\n  \n  _dragHandler!.updateResize(\n    proposedStart: proposedStart,\n    proposedEnd: proposedEnd,\n    isValid: isValid,\n    cells: _buildHighlightCells(proposedStart, proposedEnd),\n  );\n}\n```\n\n**Dependencies:** `MCalDragHandler`, time utilities\n\n**Reuses:** Month view edge navigation pattern, `handleEdgeProximity()` method\n\n### Component 11: Event Type Conversion Logic\n\n**Purpose:** Handles all-day ↔ timed conversions during drag operations.\n\n**Design:**\n```dart\n// In _MCalDayViewState\n\nbool _isDropInAllDaySection(Offset localPosition) {\n  // Check if Y position is in all-day section (negative offset from timed area)\n  return localPosition.dy < 0;\n}\n\n(DateTime start, DateTime end, bool isAllDay) _calculateConvertedEventTimes({\n  required MCalCalendarEvent originalEvent,\n  required Offset dropPosition,\n  required DateTime dropDate,\n}) {\n  final wasAllDay = originalEvent.isAllDay;\n  final isAllDayDrop = _isDropInAllDaySection(dropPosition);\n  \n  if (wasAllDay && !isAllDayDrop) {\n    // All-day → Timed conversion\n    final startTime = offsetToTime(\n      offset: dropPosition.dy,\n      date: dropDate,\n      startHour: widget.startHour,\n      hourHeight: _cachedHourHeight,\n      timeSlotDuration: widget.timeSlotDuration,\n    );\n    \n    final endTime = startTime.add(widget.allDayToTimedDuration);\n    \n    // Clamp end time if it exceeds endHour\n    final maxEndTime = DateTime(dropDate.year, dropDate.month, dropDate.day, widget.endHour, 0);\n    final clampedEnd = endTime.isAfter(maxEndTime) ? maxEndTime : endTime;\n    \n    return (startTime, clampedEnd, false);\n    \n  } else if (!wasAllDay && isAllDayDrop) {\n    // Timed → All-day conversion\n    final allDayStart = DateTime(dropDate.year, dropDate.month, dropDate.day, 0, 0);\n    final allDayEnd = DateTime(dropDate.year, dropDate.month, dropDate.day, 0, 0);\n    \n    return (allDayStart, allDayEnd, true);\n    \n  } else {\n    // No conversion: same type move\n    final duration = originalEvent.end.difference(originalEvent.start);\n    final newStart = offsetToTime(\n      offset: dropPosition.dy,\n      date: dropDate,\n      startHour: widget.startHour,\n      hourHeight: _cachedHourHeight,\n      timeSlotDuration: widget.timeSlotDuration,\n    );\n    final newEnd = newStart.add(duration);\n    \n    return (newStart, newEnd, originalEvent.isAllDay);\n  }\n}\n```\n\n**Dependencies:** Time utilities\n\n**Reuses:** Pattern similar to month view's cross-section drag\n\n### Component 12: Keyboard Navigation for Day View\n\n**Purpose:** Keyboard-based event selection, move mode, and resize mode.\n\n**Location:** `_handleKeyEvent` method in `_MCalDayViewState`\n\n**Design:**\n```dart\nKeyEventResult _handleKeyEvent(FocusNode node, KeyEvent event) {\n  if (event is! KeyDownEvent) return KeyEventResult.ignored;\n  \n  // Handle based on current mode\n  if (_isKeyboardResizeMode) {\n    return _handleKeyboardResize(event.logicalKey);\n  } else if (_isKeyboardMoveMode) {\n    return _handleKeyboardMove(event.logicalKey);\n  } else {\n    return _handleKeyboardNavigation(event.logicalKey);\n  }\n}\n\nKeyEventResult _handleKeyboardNavigation(LogicalKeyboardKey key) {\n  if (key == LogicalKeyboardKey.arrowLeft) {\n    _navigateToPreviousDay();\n    return KeyEventResult.handled;\n  } else if (key == LogicalKeyboardKey.arrowRight) {\n    _navigateToNextDay();\n    return KeyEventResult.handled;\n  } else if (key == LogicalKeyboardKey.arrowUp) {\n    _focusPreviousEvent();\n    return KeyEventResult.handled;\n  } else if (key == LogicalKeyboardKey.arrowDown) {\n    _focusNextEvent();\n    return KeyEventResult.handled;\n  } else if (key == LogicalKeyboardKey.enter || key == LogicalKeyboardKey.space) {\n    if (_focusedEvent != null) {\n      _enterKeyboardMoveMode(_focusedEvent!);\n      return KeyEventResult.handled;\n    }\n  } else if (key == LogicalKeyboardKey.home) {\n    _navigateToToday();\n    return KeyEventResult.handled;\n  } else if (key == LogicalKeyboardKey.pageUp) {\n    _navigateDaysBy(-7);\n    return KeyEventResult.handled;\n  } else if (key == LogicalKeyboardKey.pageDown) {\n    _navigateDaysBy(7);\n    return KeyEventResult.handled;\n  }\n  \n  return KeyEventResult.ignored;\n}\n\nvoid _focusPreviousEvent() {\n  final allEvents = _getAllEventsForDay().sortedBy((e) => e.start);\n  final currentIndex = _focusedEvent == null \n    ? allEvents.length \n    : allEvents.indexOf(_focusedEvent!);\n  \n  if (currentIndex > 0) {\n    setState(() {\n      _focusedEvent = allEvents[currentIndex - 1];\n      _focusedEventIndex = currentIndex - 1;\n    });\n    _scrollToEvent(_focusedEvent!);\n    _announceEventFocus(_focusedEvent!);\n  }\n}\n\nvoid _enterKeyboardMoveMode(MCalCalendarEvent event) {\n  setState(() {\n    _isKeyboardMoveMode = true;\n    _keyboardMoveEvent = event;\n    _keyboardMoveOriginalStart = event.start;\n    _keyboardMoveOriginalEnd = event.end;\n  });\n  \n  _dragHandler?.startDrag(event, event.start);\n  _announceScreenReader('Selected ${event.title}. Use arrow keys to move, R to resize, Enter to confirm, Escape to cancel.');\n}\n\nKeyEventResult _handleKeyboardMove(LogicalKeyboardKey key) {\n  if (_keyboardMoveEvent == null) return KeyEventResult.ignored;\n  \n  if (key == LogicalKeyboardKey.keyR && widget.enableDragToResize) {\n    _enterKeyboardResizeMode();\n    return KeyEventResult.handled;\n  } else if (key == LogicalKeyboardKey.arrowUp) {\n    _adjustKeyboardMoveTime(const Duration(minutes: -15));\n    return KeyEventResult.handled;\n  } else if (key == LogicalKeyboardKey.arrowDown) {\n    _adjustKeyboardMoveTime(const Duration(minutes: 15));\n    return KeyEventResult.handled;\n  } else if (key == LogicalKeyboardKey.arrowLeft) {\n    _adjustKeyboardMoveDay(-1);\n    return KeyEventResult.handled;\n  } else if (key == LogicalKeyboardKey.arrowRight) {\n    _adjustKeyboardMoveDay(1);\n    return KeyEventResult.handled;\n  } else if (key == LogicalKeyboardKey.enter) {\n    _confirmKeyboardMove();\n    return KeyEventResult.handled;\n  } else if (key == LogicalKeyboardKey.escape) {\n    _cancelKeyboardMove();\n    return KeyEventResult.handled;\n  }\n  \n  return KeyEventResult.ignored;\n}\n\nvoid _enterKeyboardResizeMode() {\n  setState(() {\n    _isKeyboardMoveMode = false;\n    _isKeyboardResizeMode = true;\n    _keyboardResizeEdge = MCalResizeEdge.end;\n  });\n  \n  _dragHandler?.startResize(_keyboardMoveEvent!, MCalResizeEdge.end);\n  _announceScreenReader('Resize mode. Adjusting end time. Use arrow keys to resize, S for start, E for end, M to return to move, Enter to confirm, Escape to cancel.');\n}\n```\n\n**Dependencies:** `MCalDragHandler`, `SemanticsService`\n\n**Reuses:** Month view keyboard navigation patterns exactly\n\n### Component 13: Day Navigator\n\n**Purpose:** Previous/Today/Next navigation controls.\n\n**Widget:** `_DayNavigator` (private StatelessWidget) or builder-provided\n\n**Design:**\n```dart\nclass _DayNavigator extends StatelessWidget {\n  final DateTime displayDate;\n  final bool canGoPrevious;\n  final bool canGoNext;\n  final VoidCallback onPrevious;\n  final VoidCallback onToday;\n  final VoidCallback onNext;\n  final String? dateFormat;\n  final Locale locale;\n  final MCalThemeData theme;\n  \n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      height: 56.0,\n      color: theme.navigatorBackgroundColor,\n      child: Row(\n        children: [\n          IconButton(\n            icon: const Icon(Icons.chevron_left),\n            onPressed: canGoPrevious ? onPrevious : null,\n            tooltip: 'Previous day',\n          ),\n          IconButton(\n            icon: const Icon(Icons.today),\n            onPressed: onToday,\n            tooltip: 'Today',\n          ),\n          Expanded(\n            child: Center(\n              child: Text(\n                _formatDate(displayDate, dateFormat, locale),\n                style: theme.navigatorTextStyle,\n              ),\n            ),\n          ),\n          IconButton(\n            icon: const Icon(Icons.chevron_right),\n            onPressed: canGoNext ? onNext : null,\n            tooltip: 'Next day',\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n**Dependencies:** Theme, intl\n\n**Reuses:** Month view navigator pattern (adapted from month to day)\n\n## Data Models\n\n### MCalTimeRange\n\n```dart\n/// Represents a time range configuration for the day view.\nclass MCalTimeRange {\n  /// Starting hour (0-23).\n  final int startHour;\n  \n  /// Ending hour (0-23).\n  final int endHour;\n  \n  /// Time slot duration for snapping.\n  final Duration timeSlotDuration;\n  \n  const MCalTimeRange({\n    required this.startHour,\n    required this.endHour,\n    required this.timeSlotDuration,\n  });\n  \n  /// Validates that start < end.\n  bool get isValid => startHour < endHour && startHour >= 0 && endHour <= 23;\n  \n  /// Total number of hours in range.\n  int get totalHours => endHour - startHour + 1;\n}\n```\n\n### MCalTimeRegion (NEW - Special Time Regions)\n\n```dart\n/// Represents a special time region with custom styling and optional interaction blocking.\n///\n/// Similar to month view's blockout dates, but time-based and with custom styling.\n/// Inspired by Syncfusion's TimeRegion feature.\nclass MCalTimeRegion {\n  /// Unique identifier for this region.\n  final String id;\n  \n  /// Start time for this region.\n  final DateTime startTime;\n  \n  /// End time for this region.\n  final DateTime endTime;\n  \n  /// Optional background color for the region.\n  /// If null, uses theme default or builder must provide styling.\n  final Color? color;\n  \n  /// Optional label text to display in the region.\n  final String? text;\n  \n  /// Whether to block interaction (prevent drops/taps) in this region.\n  /// Similar to month view's blockout dates that reject drops via onDragWillAccept.\n  /// Defaults to false (region is visual only).\n  final bool blockInteraction;\n  \n  /// Optional recurrence rule for recurring regions (e.g., daily lunch, weekends).\n  /// Uses RFC 5545 RRULE syntax like calendar events.\n  /// Example: \"FREQ=DAILY;BYHOUR=12;BYMINUTE=0;BYSECOND=0;COUNT=30\" for daily lunch.\n  final String? recurrenceRule;\n  \n  /// Optional icon to display in the region.\n  final IconData? icon;\n  \n  /// Additional custom data that can be used by timeRegionBuilder.\n  final Map<String, dynamic>? customData;\n  \n  const MCalTimeRegion({\n    required this.id,\n    required this.startTime,\n    required this.endTime,\n    this.color,\n    this.text,\n    this.blockInteraction = false,\n    this.recurrenceRule,\n    this.icon,\n    this.customData,\n  });\n  \n  /// Whether this region contains the given time.\n  bool contains(DateTime time) {\n    return !time.isBefore(startTime) && time.isBefore(endTime);\n  }\n  \n  /// Whether this region overlaps with the given time range.\n  bool overlaps(DateTime rangeStart, DateTime rangeEnd) {\n    return startTime.isBefore(rangeEnd) && endTime.isAfter(rangeStart);\n  }\n  \n  /// Copy with method for modifications.\n  MCalTimeRegion copyWith({\n    String? id,\n    DateTime? startTime,\n    DateTime? endTime,\n    Color? color,\n    String? text,\n    bool? blockInteraction,\n    String? recurrenceRule,\n    IconData? icon,\n    Map<String, dynamic>? customData,\n  }) {\n    return MCalTimeRegion(\n      id: id ?? this.id,\n      startTime: startTime ?? this.startTime,\n      endTime: endTime ?? this.endTime,\n      color: color ?? this.color,\n      text: text ?? this.text,\n      blockInteraction: blockInteraction ?? this.blockInteraction,\n      recurrenceRule: recurrenceRule ?? this.recurrenceRule,\n      icon: icon ?? this.icon,\n      customData: customData ?? this.customData,\n    );\n  }\n}\n```\n\n### MCalDayEventLayout\n\n```dart\n/// Layout information for a timed event in the day view.\nclass MCalDayEventLayout {\n  /// The event being laid out.\n  final MCalCalendarEvent event;\n  \n  /// Column index (0-based) for overlap handling.\n  final int columnIndex;\n  \n  /// Total number of columns needed for this overlap group.\n  final int totalColumns;\n  \n  /// Vertical offset from top in pixels.\n  final double topOffset;\n  \n  /// Height in pixels.\n  final double height;\n  \n  /// Calculated start time (may differ from event.start due to rounding).\n  final DateTime startTime;\n  \n  /// Calculated end time.\n  final DateTime endTime;\n  \n  const MCalDayEventLayout({\n    required this.event,\n    required this.columnIndex,\n    required this.totalColumns,\n    required this.topOffset,\n    required this.height,\n    required this.startTime,\n    required this.endTime,\n  });\n}\n```\n\n### Context Objects (in mcal_day_view_contexts.dart)\n\n**MCalTimeSlotContext:**\n```dart\n/// Context provided to onTimeSlotTap and onTimeSlotLongPress callbacks.\n/// \n/// Similar to month view's MCalCellContext for empty cell taps.\nclass MCalTimeSlotContext {\n  /// The display date.\n  final DateTime date;\n  \n  /// The time corresponding to the tap position (snapped to timeSlotDuration).\n  final DateTime time;\n  \n  /// Whether the tap was in the all-day area (true) or timed area (false).\n  final bool isAllDayArea;\n  \n  /// Hour component of the time (0-23).\n  final int? hour;\n  \n  /// Minute component of the time (0-59).\n  final int? minute;\n  \n  /// Local offset where the tap occurred (useful for custom positioning).\n  final Offset offset;\n  \n  const MCalTimeSlotContext({\n    required this.date,\n    required this.time,\n    required this.isAllDayArea,\n    required this.offset,\n    this.hour,\n    this.minute,\n  });\n}\n```\n\n**MCalTimeLabelContext:**\n```dart\nclass MCalTimeLabelContext {\n  final int hour;\n  final DateTime time;\n  final Locale locale;\n  \n  const MCalTimeLabelContext({\n    required this.hour,\n    required this.time,\n    required this.locale,\n  });\n}\n```\n\n**MCalTimedEventTileContext:**\n```dart\nclass MCalTimedEventTileContext {\n  final MCalCalendarEvent event;\n  final DateTime displayDate;\n  final int columnIndex;\n  final int totalColumns;\n  final DateTime startTime;\n  final DateTime endTime;\n  final bool isFocused;\n  final bool isBeingDragged;\n  final bool isDropTargetPreview;\n  \n  const MCalTimedEventTileContext({\n    required this.event,\n    required this.displayDate,\n    required this.columnIndex,\n    required this.totalColumns,\n    required this.startTime,\n    required this.endTime,\n    this.isFocused = false,\n    this.isBeingDragged = false,\n    this.isDropTargetPreview = false,\n  });\n}\n```\n\n**MCalDayHeaderContext:**\n```dart\nclass MCalDayHeaderContext {\n  final DateTime date;\n  final bool isToday;\n  final int weekNumber;  // NEW - ISO 8601 week number\n  final Locale locale;\n  \n  const MCalDayHeaderContext({\n    required this.date,\n    required this.isToday,\n    required this.weekNumber,\n    required this.locale,\n  });\n}\n```\n\n**MCalCurrentTimeContext:**\n```dart\nclass MCalCurrentTimeContext {\n  final DateTime currentTime;\n  final double offset;\n  final bool isRTL;\n  \n  const MCalCurrentTimeContext({\n    required this.currentTime,\n    required this.offset,\n    required this.isRTL,\n  });\n}\n```\n\n**MCalGridlineContext:**\n```dart\n/// Type of gridline being rendered.\nenum MCalGridlineType {\n  /// Primary hour gridline (e.g., 9:00, 10:00).\n  hour,\n  /// Major subdivision (e.g., 30-minute intervals).\n  major,\n  /// Minor subdivision (e.g., 15-minute intervals).\n  minor,\n}\n\nclass MCalGridlineContext {\n  /// Hour this gridline belongs to (0-23).\n  final int hour;\n  \n  /// Minute offset within the hour (0-59).\n  final int minute;\n  \n  /// Vertical offset in pixels from top of time range.\n  final double offset;\n  \n  /// Type of gridline (hour, major, or minor).\n  final MCalGridlineType type;\n  \n  /// The configured interval in minutes (e.g., 15 for 15-minute gridlines).\n  final int intervalMinutes;\n  \n  const MCalGridlineContext({\n    required this.hour,\n    required this.minute,\n    required this.offset,\n    required this.type,\n    required this.intervalMinutes,\n  });\n  \n  /// True if this is an hour gridline (minute == 0).\n  bool get isHour => type == MCalGridlineType.hour;\n  \n  /// True if this is a major subdivision (e.g., 30 minutes).\n  bool get isMajor => type == MCalGridlineType.major;\n  \n  /// True if this is a minor subdivision.\n  bool get isMinor => type == MCalGridlineType.minor;\n}\n```\n\n**MCalTimeRegionContext:** (NEW)\n```dart\n/// Context for custom time region builder.\nclass MCalTimeRegionContext {\n  /// The time region being rendered.\n  final MCalTimeRegion region;\n  \n  /// The date this region is being rendered for.\n  final DateTime displayDate;\n  \n  /// Vertical offset in pixels from top of time range.\n  final double startOffset;\n  \n  /// Height in pixels for this region.\n  final double height;\n  \n  const MCalTimeRegionContext({\n    required this.region,\n    required this.displayDate,\n    required this.startOffset,\n    required this.height,\n  });\n  \n  /// Whether this region blocks interaction.\n  bool get isBlocked => region.blockInteraction;\n  \n  /// Start time for this region occurrence on displayDate.\n  DateTime get startTime => region.startTime;\n  \n  /// End time for this region occurrence on displayDate.\n  DateTime get endTime => region.endTime;\n}\n```\n\n**MCalDayLayoutContext:**\n```dart\n/// Context for custom day layout builder.\nclass MCalDayLayoutContext {\n  final List<MCalCalendarEvent> events;\n  final DateTime displayDate;\n  final int startHour;\n  final int endHour;\n  final double hourHeight;\n  final double areaWidth;\n  \n  const MCalDayLayoutContext({\n    required this.events,\n    required this.displayDate,\n    required this.startHour,\n    required this.endHour,\n    required this.hourHeight,\n    required this.areaWidth,\n  });\n}\n```\n\n### Callback Detail Classes (extend mcal_callback_details.dart)\n\n**MCalEventDroppedDetails extension:**\n```dart\n// Add field to existing class\nclass MCalEventDroppedDetails {\n  // ... existing fields ...\n  \n  /// Indicates event type conversion: 'allDayToTimed', 'timedToAllDay', or null.\n  final String? typeConversion;\n  \n  const MCalEventDroppedDetails({\n    // ... existing parameters ...\n    this.typeConversion,\n  });\n}\n```\n\n**MCalEventDragWillAcceptDetails:** (NEW - for validation callback)\n```dart\n/// Details provided to onDragWillAccept callback for validation.\n/// \n/// Similar to month view's onDragWillAccept, used to validate drops before accepting them.\n/// Enables blocking drops on special time regions (blockInteraction: true).\nclass MCalEventDragWillAcceptDetails {\n  /// The event being dragged.\n  final MCalCalendarEvent event;\n  \n  /// Proposed start date/time after drop.\n  final DateTime proposedStartDate;\n  \n  /// Proposed end date/time after drop.\n  final DateTime proposedEndDate;\n  \n  /// Whether the event will be all-day after drop.\n  final bool isAllDay;\n  \n  const MCalEventDragWillAcceptDetails({\n    required this.event,\n    required this.proposedStartDate,\n    required this.proposedEndDate,\n    required this.isAllDay,\n  });\n}\n```\n\n## Error Handling\n\n### Error Scenarios\n\n1. **Time calculations exceed day boundaries**\n   - **Handling:** Clamp to `startHour:00` and `endHour:00`, or reject drag/resize if invalid\n   - **User Impact:** Event snaps to boundary or shows invalid feedback\n\n2. **Drag callback returns false**\n   - **Handling:** `onEventDropped` returns false → revert event to original position, `dragHandler.cancelDrag()`\n   - **User Impact:** Event animates back to original position (or snaps if animations disabled)\n\n3. **Resize below minimum duration**\n   - **Handling:** Enforce minimum of 1 time slot, prevent edge from crossing opposite edge\n   - **User Impact:** Handle stops moving when minimum is reached\n\n4. **Invalid time range (startHour >= endHour)**\n   - **Handling:** Assert in debug, clamp in release, or show error via `errorBuilder`\n   - **User Impact:** Error message or clamped to valid range\n\n5. **Controller loading fails**\n   - **Handling:** Show error UI via `errorBuilder` callback\n   - **User Impact:** Error message with retry option\n\n6. **Scroll controller disposed during animation**\n   - **Handling:** Check `mounted` before all `setState` calls, cancel timers in `dispose`\n   - **User Impact:** None - silent failure prevention\n\n7. **Cross-day navigation at boundaries**\n   - **Handling:** Check `canNavigateTo(date)` before navigating, disable edge navigation at limits\n   - **User Impact:** Edge navigation stops at `minDate`/`maxDate`\n\n8. **Overlapping events calculation fails**\n   - **Handling:** Catch exceptions in overlap detection, fall back to stacked layout\n   - **User Impact:** Events stack instead of showing side-by-side (degraded but functional)\n\n## Testing Strategy\n\n### Unit Testing\n\n**Time Utilities (`test/utils/time_utils_test.dart`):**\n- Test `timeToOffset()` with various hours, minutes, hour heights\n- Test `offsetToTime()` with various offsets, slot durations (1, 5, 10, 15, 30, 60 minutes)\n- Test time slot snapping edge cases (midnight, boundaries, DST transitions)\n- Test `durationToHeight()` calculations\n- Verify DST-safe behavior (time calculations near spring-forward/fall-back)\n\n**Overlap Detection (`test/utils/overlap_detection_test.dart` or inline tests):**\n- Single event: Returns 1 column\n- Two non-overlapping events: Returns 1 column each\n- Two overlapping events: Returns 2 columns\n- Three events with partial overlap: Correct column assignment\n- All events overlap: Returns n columns for n events\n- Events with identical times: Sorted by duration (longest first)\n- Zero-duration events: Handled gracefully\n\n### Widget Testing\n\n**Layout Rendering (`test/widgets/mcal_day_view_test.dart`):**\n- Time legend renders with correct hour count and positioning (LTR/RTL)\n- Gridlines render at correct intervals (hour and half-hour)\n- Day header displays correct date and position\n- All-day section renders events horizontally\n- All-day overflow indicator shows when events exceed `maxRows`\n- Timed events render at correct vertical positions\n- Event heights match duration\n- Overlapping events render in columns\n- Current time indicator renders on today, updates position\n- Empty day renders without errors\n\n**Drag and Drop (`test/widgets/mcal_day_view_drag_test.dart`):**\n- Long-press initiates drag\n- Vertical drag updates proposed time\n- Drop target preview renders at proposed position\n- Time slot snapping works correctly\n- `onDragWillAccept` validation called with correct times\n- `onEventDropped` called on release with correct details\n- Drag cancellation (Escape key, invalid drop) works\n- Edge navigation triggers at left/right edges\n- Cross-day drag preserves time-of-day\n- Timed → all-day conversion works when dropped in all-day section\n- All-day → timed conversion works when dropped in timed section\n- Converted event has correct times/dates\n\n**Resize (`test/widgets/mcal_day_view_resize_test.dart`):**\n- Top edge resize changes start time\n- Bottom edge resize changes end time\n- Minimum duration enforced (1 time slot)\n- `onResizeWillAccept` validation called\n- `onEventResized` called with correct details\n- Resize handles render on timed events\n- All-day events have horizontal resize handles\n- Edge navigation during resize works\n- Cross-day resize preserves event correctly\n\n**Keyboard Navigation (`test/widgets/mcal_day_view_keyboard_test.dart`):**\n- Arrow keys navigate days and events\n- Enter/Space enters move mode\n- R key enters resize mode\n- Move mode: arrows adjust time/date\n- Resize mode: arrows adjust edge, S/E switch edge, M exits\n- Screen reader announcements occur\n- Validation applies to keyboard operations\n\n**RTL Support (`test/widgets/mcal_day_view_rtl_test.dart`):**\n- Time legend on right side\n- Day header at top-right\n- Current time indicator dot on right\n- All drag/resize operations work correctly\n- Edge navigation directions reversed\n\n### Integration Testing\n\n**Complete Workflows (`test/integration/mcal_day_view_integration_test.dart`):**\n- Create event via time slot tap → drag → drop → verify in controller\n- Create event → resize top edge → verify updated duration\n- Recurring event → drag → verify modified exception created\n- All-day event → drag to timed section → verify conversion\n- Timed event → drag to all-day → verify conversion\n- Navigate to yesterday → today → tomorrow → verify dates\n- Auto-scroll to current time on load → verify scroll position\n- Load 50+ events → verify performance (frame times)\n\n### Performance Testing\n\n- Render with 100+ events: Measure frame times (target: `<16ms` per frame)\n- Scrolling with many events: Verify smooth 60fps\n- Drag operations: Verify 60fps during drag (debounced updates)\n- Memory: Load large event set → verify no leaks → dispose → verify cleanup\n\n## Theme Property Additions to MCalThemeData\n\n**Add to `lib/src/styles/mcal_theme.dart`:**\n\n```dart\nclass MCalThemeData {\n  // ... existing properties ...\n  \n  // Day View: Day Header (NEW)\n  final TextStyle? dayHeaderDayOfWeekStyle;\n  final TextStyle? dayHeaderDateStyle;\n  \n  // Day View: Week Number (NEW - inspired by Kalender)\n  final Color? weekNumberBackgroundColor;\n  final Color? weekNumberTextColor;\n  final TextStyle? weekNumberTextStyle;\n  \n  // Day View: Time Legend\n  final double? timeLegendWidth;\n  final TextStyle? timeLegendTextStyle;\n  final Color? timeLegendBackgroundColor;\n  \n  // Day View: Gridlines\n  final Color? hourGridlineColor;\n  final double? hourGridlineWidth;\n  final Color? majorGridlineColor;  // e.g., 30-minute marks\n  final double? majorGridlineWidth;\n  final Color? minorGridlineColor;  // e.g., 15-minute marks\n  final double? minorGridlineWidth;\n  \n  // Day View: Current Time Indicator\n  final Color? currentTimeIndicatorColor;\n  final double? currentTimeIndicatorWidth;\n  final double? currentTimeIndicatorDotRadius;\n  \n  // Day View: All-Day Section\n  final double? allDaySectionHeight;\n  final int? allDaySectionMaxRows;\n  \n  // Day View: Timed Events\n  final double? hourHeight;\n  final double? timedEventMinHeight;\n  final double? timedEventBorderRadius;\n  final EdgeInsets? timedEventPadding;\n  \n  // Day View: Special Time Regions (NEW)\n  final Color? specialTimeRegionColor;       // Visual-only regions\n  final Color? blockedTimeRegionColor;       // Blocked (blockInteraction: true) regions\n  final Color? timeRegionBorderColor;\n  final Color? timeRegionTextColor;\n  final TextStyle? timeRegionTextStyle;\n  \n  // ... constructor, copyWith, lerp, fromTheme updates ...\n}\n```\n\n**Default values in `fromTheme()`:**\n```dart\nstatic MCalThemeData fromTheme(ThemeData theme) {\n  final colorScheme = theme.colorScheme;\n  final textTheme = theme.textTheme;\n  \n  return MCalThemeData(\n    // ... existing defaults ...\n    \n    // Day view defaults\n    \n    // Day header\n    dayHeaderDayOfWeekStyle: textTheme.labelMedium?.copyWith(\n      color: colorScheme.onSurfaceVariant,\n      fontWeight: FontWeight.w500,\n    ),\n    dayHeaderDateStyle: textTheme.headlineMedium?.copyWith(\n      color: colorScheme.onSurface,\n      fontWeight: FontWeight.bold,\n    ),\n    \n    // Week number (NEW)\n    weekNumberBackgroundColor: colorScheme.surfaceContainerHigh,\n    weekNumberTextColor: colorScheme.onSurfaceVariant,\n    weekNumberTextStyle: textTheme.labelSmall?.copyWith(\n      color: colorScheme.onSurfaceVariant,\n      fontWeight: FontWeight.w500,\n    ),\n    \n    timeLegendWidth: 60.0,\n    timeLegendTextStyle: textTheme.labelSmall?.copyWith(\n      color: colorScheme.onSurfaceVariant,\n    ),\n    timeLegendBackgroundColor: colorScheme.surfaceContainerLow,\n    hourGridlineColor: colorScheme.outline.withValues(alpha: 0.2),\n    hourGridlineWidth: 1.0,\n    majorGridlineColor: colorScheme.outline.withValues(alpha: 0.15),\n    majorGridlineWidth: 1.0,\n    minorGridlineColor: colorScheme.outline.withValues(alpha: 0.08),\n    minorGridlineWidth: 0.5,\n    currentTimeIndicatorColor: colorScheme.primary,\n    currentTimeIndicatorWidth: 2.0,\n    currentTimeIndicatorDotRadius: 6.0,\n    allDaySectionMaxRows: 3,\n    timedEventMinHeight: 20.0,\n    timedEventBorderRadius: 4.0,\n    timedEventPadding: const EdgeInsets.all(2.0),\n    \n    // Special time regions (NEW)\n    specialTimeRegionColor: colorScheme.surfaceContainer.withValues(alpha: 0.5),\n    blockedTimeRegionColor: colorScheme.surfaceContainerHighest.withValues(alpha: 0.7),\n    timeRegionBorderColor: colorScheme.outline.withValues(alpha: 0.3),\n    timeRegionTextColor: colorScheme.onSurfaceVariant.withValues(alpha: 0.6),\n    timeRegionTextStyle: textTheme.labelSmall?.copyWith(\n      color: colorScheme.onSurfaceVariant.withValues(alpha: 0.6),\n    ),\n  );\n}\n```\n\n## Widget Hierarchy\n\n```\nMCalDayView\n└─ _MCalDayViewState\n    └─ Column\n        ├─ _DayNavigator (if showNavigator)\n        │   └─ Row [Prev | Today | Date | Next]\n        │\n        └─ Expanded\n            └─ Row\n                ├─ _TimeLegendColumn (if !isRTL)\n                │   └─ Stack [Hour labels positioned]\n                │\n                ├─ Expanded (events area)\n                │   └─ Column\n                │       ├─ _DayHeader\n                │       │   └─ Positioned (top-left or top-right)\n                │       │\n                │       ├─ _AllDayEventsSection\n                │       │   └─ Wrap [All-day event tiles]\n                │       │\n                │       └─ Expanded\n                │           └─ SingleChildScrollView (vertical)\n                │               └─ DragTarget (for drop handling)\n                │                   └─ Stack (5 layers)\n                │                       ├─ Layer 1: _GridlinesLayer\n                │                       ├─ Layer 2: _TimedEventsLayer\n                │                       │   └─ Stack [Positioned event tiles]\n                │                       ├─ Layer 3: _CurrentTimeIndicator\n                │                       ├─ Layer 4: _DropTargetPreviewLayer (ListenableBuilder)\n                │                       │   └─ Stack [Preview tiles at proposed position]\n                │                       └─ Layer 5: _DropTargetOverlayLayer (ListenableBuilder)\n                │                           └─ Container [Highlighted time slots]\n                │\n                └─ _TimeLegendColumn (if isRTL)\n```\n\n## Layered Rendering (similar to month view)\n\n**Layer 1: Gridlines**\n- Renders first (bottom of stack)\n- Static positioning based on hour intervals\n- Conditional rendering based on `showHalfHourLines`\n\n**Layer 2: Event Tiles**\n- Timed events with absolute positioning\n- Column layout for overlaps\n- Drag sources via `MCalDraggableEventTile`\n- Resize handles when enabled\n\n**Layer 3: Current Time Indicator**\n- Renders above events (more visible)\n- Positioned absolutely based on current time\n- Updates every minute via timer\n\n**Layer 4: Drop Target Preview**\n- Wrapped in `ListenableBuilder` listening to `MCalDragHandler`\n- Shows phantom event tile at proposed drop position\n- Opacity or border indicates valid/invalid\n- Updates in real-time during drag\n\n**Layer 5: Drop Target Overlay**\n- Wrapped in `ListenableBuilder`\n- Highlights time slot range being targeted\n- Semi-transparent overlay\n- Renders above all other layers for visibility\n\n## State Management\n\n**Widget State (_MCalDayViewState):**\n```dart\nclass _MCalDayViewState extends State<MCalDayView> {\n  // Controller integration\n  late DateTime _displayDate;\n  List<MCalCalendarEvent> _allEvents = [];\n  List<MCalCalendarEvent> _allDayEvents = [];\n  List<MCalCalendarEvent> _timedEvents = [];\n  bool _isLoading = false;\n  Object? _error;\n  \n  // Drag state\n  MCalDragHandler? _dragHandler;\n  bool _isDragActive = false;\n  bool _isResizeActive = false;\n  \n  // Scroll state\n  ScrollController? _scrollController;\n  bool _autoScrollDone = false;\n  \n  // Layout cache\n  double _cachedHourHeight = 0.0;\n  double _cachedAreaWidth = 0.0;\n  \n  // Keyboard state\n  FocusNode _focusNode = FocusNode();\n  MCalCalendarEvent? _focusedEvent;\n  int _focusedEventIndex = -1;\n  bool _isKeyboardMoveMode = false;\n  bool _isKeyboardResizeMode = false;\n  MCalCalendarEvent? _keyboardMoveEvent;\n  DateTime? _keyboardMoveOriginalStart;\n  DateTime? _keyboardMoveOriginalEnd;\n  MCalResizeEdge _keyboardResizeEdge = MCalResizeEdge.end;\n  \n  // Current time\n  Timer? _currentTimeTimer;\n  DateTime _currentTime = DateTime.now();\n  \n  // Keys for layout access\n  final GlobalKey _timedEventsAreaKey = GlobalKey();\n  \n  @override\n  void initState() {\n    super.initState();\n    _displayDate = widget.controller.displayDate;\n    _scrollController = widget.scrollController ?? ScrollController();\n    widget.controller.addListener(_onControllerChanged);\n    _loadEvents();\n    _startCurrentTimeTimer();\n  }\n  \n  @override\n  void dispose() {\n    _currentTimeTimer?.cancel();\n    _dragHandler?.dispose();\n    _focusNode.dispose();\n    if (widget.scrollController == null) {\n      _scrollController?.dispose();\n    }\n    widget.controller.removeListener(_onControllerChanged);\n    super.dispose();\n  }\n}\n```\n\n## RTL Support Implementation\n\n**Detection:**\n```dart\nbool _isRTL(BuildContext context) {\n  final localizations = MCalLocalizations();\n  final resolvedLocale = widget.locale ?? Localizations.localeOf(context);\n  return localizations.isRTL(resolvedLocale);\n}\n```\n\n**Application:**\n- Time legend: `if (!isRTL) _TimeLegendColumn(...) else Expanded(...)`\n- Day header: `Align(alignment: isRTL ? Alignment.topRight : Alignment.topLeft, ...)`\n- Current time indicator dot: `if (!isRTL) _buildDot() else Expanded(...)`\n- Edge navigation: `nearLeftEdge` → navigate to `isRTL ? next : previous` day\n- All builder contexts include `isRTL` field for custom rendering\n\n## Navigation Pattern\n\n**Approach:** Single-page with `setState` (simpler than PageView)\n\nUnlike month view which uses `PageView.builder` for infinite scrolling, day view uses a simpler approach:\n- Display date stored in `_displayDate` state field\n- Navigation methods call `setState(() { _displayDate = newDate; })`\n- Controller updated via `widget.controller.setDisplayDate(newDate)`\n- Events reloaded via `_loadEvents()` which calls `controller.getEventsForRange()`\n\n**Why simpler approach:**\n- Single day is lighter weight than full month grid\n- No need for \"infinite\" scrolling (PageView complexity)\n- Faster navigation (no animation overhead unless desired)\n- Easier to implement cross-day drag persistence (no page widget disposal)\n\n**Animation (if enabled):**\n- Can animate `_displayDate` change using `AnimatedSwitcher` or custom transition\n- Respects `enableAnimations` and OS reduced motion preference\n\n## Performance Optimizations\n\n1. **Lazy drag handler creation**: Only create `MCalDragHandler` when first drag occurs\n2. **Cached layout values**: Store `_cachedHourHeight`, `_cachedAreaWidth` in `didChangeDependencies`\n3. **Viewport-based rendering**: Only render events within visible scroll region (+ buffer)\n4. **Debounced drag updates**: Use same 16ms debounce as month view for 60fps\n5. **Const constructors**: Use `const` where possible for immutable widgets\n6. **ListView vs Stack**: Use `Stack` with `Positioned` (not `ListView`) for precise event positioning\n7. **Timer efficiency**: Current time timer fires once per minute (not continuously)\n8. **Controller listener**: Only rebuild when events for displayed date change\n\n## Accessibility Implementation\n\n**Semantic Labels:**\n- Time legend hours: \"9 AM\", \"2 PM\", etc.\n- Event tiles: \"{title}, {start time} to {end time}, {duration}\"\n- Current time indicator: \"Current time: {time}\"\n- Navigator buttons: \"Previous day\", \"Today\", \"Next day\"\n- Resize handles: \"Resize start time\" / \"Resize end time\"\n\n**Screen Reader Announcements:**\n```dart\nvoid _announceScreenReader(String message) {\n  SemanticsService.announce(\n    message,\n    Directionality.of(context),\n  );\n}\n\n// Examples:\n_announceScreenReader('Moving Team Meeting to 2:30 PM');\n_announceScreenReader('Moved Team Meeting to 2:30 PM on Wednesday, February 14');\n_announceScreenReader('Resize mode. Adjusting end time.');\n_announceScreenReader('Resizing Team Meeting end to 4:00 PM, 2 hours');\n```\n\n**Focus Management:**\n- `FocusNode` attached to day view root\n- `onKeyEvent` handler for keyboard navigation\n- `requestFocus()` on event tap when `autoFocusOnEventTap` is true\n- Focus indicator via `focusedEventBorderColor` or custom style\n\n**Reduced Motion:**\n```dart\nbool _resolveAnimationsEnabled(BuildContext context) {\n  if (widget.enableAnimations != null) return widget.enableAnimations!;\n  return !MediaQuery.disableAnimationsOf(context);\n}\n```\n\n## Integration with Existing Systems\n\n**MCalEventController:**\n- Call `getEventsForRange()` for single day: `DateTimeRange(start: dayStart, end: dayEnd)`\n- Listen for changes: `controller.addListener(_onControllerChanged)`\n- Update events: `controller.addEvents([updatedEvent])`\n- Recurring exceptions: `controller.modifyOccurrence(seriesId, originalDate, modifiedEvent)`\n\n**MCalDragHandler:**\n- Create lazily: `_dragHandler ??= MCalDragHandler()`\n- Start drag: `_dragHandler!.startDrag(event, sourceDate/time)`\n- Update drag: Calculate time from Y position, call `updateProposedDropRange()`\n- Complete drag: `completeDrag()` returns proposed time, update controller\n- Start resize: `_dragHandler!.startResize(event, edge)`\n- Update resize: Calculate new time, call `updateResize()`\n- Complete resize: `completeResize()` returns times, update controller\n\n**MCalTheme:**\n- Read: `final theme = MCalTheme.of(context)`\n- Apply: Use theme properties throughout rendering\n- Builder contexts: Pass theme-relevant properties in context objects\n\n## Builder Pattern Examples\n\n**Day Layout Builder (custom overlap layout):**\n```dart\ndayLayoutBuilder: (context, layoutContext) {\n  // Custom layout: stack events with offset instead of columns\n  return Stack(\n    children: layoutContext.events.map((event) {\n      final index = layoutContext.events.indexOf(event);\n      return Positioned(\n        top: timeToOffset(event.start, ...),\n        left: index * 4.0,  // 4px offset per event\n        right: 0,\n        height: durationToHeight(event.end.difference(event.start), ...),\n        child: Container(...),  // Custom tile rendering\n      );\n    }).toList(),\n  );\n}\n```\n\n**Time Label Builder:**\n```dart\ntimeLabelBuilder: (context, labelContext) {\n  return Text(\n    '${labelContext.hour}:00',\n    style: TextStyle(fontSize: 10, color: Colors.grey),\n  );\n}\n```\n\n## File Organization\n\n**Main widget file:** `lib/src/widgets/mcal_day_view.dart` (~6,000-7,000 lines)\n- `MCalDayView` widget class (~200 lines)\n- `_MCalDayViewState` class (~800 lines)\n- `_DayNavigator` widget (~100 lines)\n- `_TimeLegendColumn` widget (~150 lines)\n- `_GridlinesLayer` widget (~100 lines)\n- `_AllDayEventsSection` widget and state (~400 lines)\n- `_TimedEventsLayer` widget (~300 lines)\n- `_CurrentTimeIndicator` widget and state (~150 lines)\n- `_TimeResizeHandle` widget (~100 lines)\n- Helper methods (~3,000+ lines for drag, resize, keyboard, layout calculations)\n\n**Contexts file:** `lib/src/widgets/mcal_day_view_contexts.dart` (~600-800 lines)\n- 8-10 context classes (~60-80 lines each)\n\n**Time utilities:** `lib/src/utils/time_utils.dart` (~300-400 lines)\n- Pure functions for time calculations\n- Overlap detection algorithm (~100 lines)\n- Time formatting helpers (~50 lines)\n\n## Example App Integration Pattern\n\n**Showcase widget** (`example/lib/views/day_view/day_view_showcase.dart`):\n```dart\nclass DayViewShowcase extends StatefulWidget {\n  final Locale currentLocale;\n  final bool isDarkMode;\n  \n  @override\n  State<DayViewShowcase> createState() => _DayViewShowcaseState();\n}\n\nclass _DayViewShowcaseState extends State<DayViewShowcase> \n    with SingleTickerProviderStateMixin {\n  late TabController _tabController;\n  late MCalEventController _eventController;\n  DateTime? _selectedDate;\n  \n  static const _styles = [\n    StyleTabInfo(name: 'Default', description: 'Out-of-the-box...'),\n    StyleTabInfo(name: 'Modern', description: 'Rounded and elevated...'),\n    StyleTabInfo(name: 'Classic', description: 'Traditional grid...'),\n    StyleTabInfo(name: 'Minimal', description: 'Ultra-clean...'),\n    StyleTabInfo(name: 'Colorful', description: 'Bold and vibrant...'),\n    StyleTabInfo(name: 'Features Demo', description: 'Interactive controls...'),\n  ];\n  \n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        TabBar(controller: _tabController, tabs: _buildTabs()),\n        Expanded(\n          child: TabBarView(\n            controller: _tabController,\n            children: [\n              DefaultDayStyle(controller: _eventController, ...),\n              ModernDayStyle(controller: _eventController, ...),\n              ClassicDayStyle(controller: _eventController, ...),\n              MinimalDayStyle(controller: _eventController, ...),\n              ColorfulDayStyle(controller: _eventController, ...),\n              FeaturesDemoDayStyle(controller: _eventController, ...),\n            ],\n          ),\n        ),\n      ],\n    );\n  }\n}\n```\n\n**Each style file pattern:**\n```dart\nclass ModernDayStyle extends StatelessWidget {\n  final MCalEventController eventController;\n  final Locale locale;\n  final bool isDarkMode;\n  final String description;\n  \n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        StyleDescription(description: description),\n        Expanded(\n          child: MCalTheme(\n            data: _buildCustomTheme(context),\n            child: MCalDayView(\n              controller: eventController,\n              // ... custom configuration ...\n            ),\n          ),\n        ),\n      ],\n    );\n  }\n}\n```\n\nThis design provides a complete technical blueprint for implementing MCalDayView with all requirements satisfied, following established patterns from MCalMonthView, and ensuring consistency across the package.\n",
  "fileStats": {
    "size": 110617,
    "lines": 3431,
    "lastModified": "2026-02-14T06:58:17.780Z"
  },
  "comments": []
}