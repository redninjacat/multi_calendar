{
  "id": "snapshot_1770871109223_hpjw8ts38",
  "approvalId": "approval_1770871109218_pmz5ajymb",
  "approvalTitle": "Design: Recurring Events",
  "version": 1,
  "timestamp": "2026-02-12T04:38:29.223Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Design Document: Recurring Events\n\n## Overview\n\nThis design adds recurring event support across three layers of the multi_calendar package:\n1. **Model layer** — New wrapper types (`MCalRecurrenceRule`, `MCalWeekDay`, `MCalRecurrenceException`, `MCalEventChangeInfo`) and an updated `MCalCalendarEvent` model.\n2. **Controller layer** — `MCalEventController` gains a recurrence expansion engine, exception store, granular caching, change notification metadata, and series management methods.\n3. **Widget layer** — `MCalEventTileContext` is enriched with recurrence metadata; drag-and-drop auto-creates exceptions; `MCalEventDroppedDetails` gains recurrence fields.\n4. **Example app** — A full-featured recurrence editor dialog (not part of the package).\n\nInternally, the `teno_rrule` package handles RFC 5545 expansion. It is imported only in `mcal_recurrence_rule.dart` and never appears in the public API.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n- **Widget-based Architecture / Controller Pattern**: All recurring event logic lives in `MCalEventController`, consistent with the controller pattern. Views receive expanded occurrences through the existing `getEventsForRange()` path.\n- **Builder Pattern**: Recurrence metadata flows to builder callbacks via `MCalEventTileContext`, enabling custom rendering without package changes.\n- **Delegation for Storage**: The controller manages recurrence state in memory. Persistence is the consumer's responsibility — mutation methods return enough info for async persistence.\n\n### Project Structure (structure.md)\n- New model files in `lib/src/models/`.\n- Controller changes in `lib/src/controllers/mcal_event_controller.dart`.\n- Context enrichment in `lib/src/widgets/mcal_month_view_contexts.dart`.\n- Drag-drop detail changes in `lib/src/widgets/mcal_callback_details.dart`.\n- Example editor in `example/lib/widgets/` and integrated into the Features demo.\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n- **`MCalCalendarEvent`** (`lib/src/models/mcal_calendar_event.dart`): Extended with `recurrenceRule` field. `copyWith`, `==`, `hashCode` patterns already established.\n- **`MCalEventController`** (`lib/src/controllers/mcal_event_controller.dart`): `_eventsById` map, `getEventsForRange()`, `addEvents()`, `removeEvents()`, `notifyListeners()` — all reused and extended.\n- **`MCalEventTileContext`** (`lib/src/widgets/mcal_month_view_contexts.dart`): Extended with recurrence fields following existing optional-field pattern (like `isDropTargetPreview`, `dropValid`).\n- **`MCalEventDroppedDetails`** (`lib/src/widgets/mcal_callback_details.dart`): Extended with `isRecurring` and `seriesId` fields.\n- **`_handleDrop()`** (`lib/src/widgets/mcal_month_view.dart`): Modified to detect recurring occurrences and create reschedule exceptions.\n\n### Integration Points\n- **`getEventsForRange()`** — Enhanced to transparently expand recurring events and apply exceptions before returning.\n- **`_handleDrop()`** — Enhanced to check if the dropped event is a recurring occurrence and auto-create a reschedule exception.\n- **Month view event construction** — Where `MCalEventTileContext` is built (in `_WeekRowWidget` and `_buildDropTargetTileEventBuilder`), recurrence metadata is now populated.\n\n## Architecture\n\n### Data Flow\n\n```mermaid\nflowchart TD\n    subgraph consumer [Consumer App]\n        DB[\"Persistence Layer (Drift/Firestore/etc)\"]\n        LoadEvents[\"loadEvents override\"]\n        MutationPersist[\"Persist mutation async\"]\n    end\n\n    subgraph models [Model Layer]\n        MasterEvent[\"MCalCalendarEvent + MCalRecurrenceRule\"]\n        ExceptionModel[\"MCalRecurrenceException\"]\n        ChangeInfo[\"MCalEventChangeInfo\"]\n    end\n\n    subgraph controller [MCalEventController]\n        EventStore[\"_eventsById (masters + standalone)\"]\n        ExceptionStore[\"_exceptionsBySeriesId\"]\n        ExpansionCache[\"_expandedCache (DateTimeRange -> occurrences)\"]\n        Expander[\"_expandRecurringEvent()\"]\n        ExApplicator[\"_applyExceptions()\"]\n        RangeQuery[\"getEventsForRange()\"]\n    end\n\n    subgraph views [Widget Layer]\n        MonthView[\"MCalMonthView\"]\n        TileContext[\"MCalEventTileContext + recurrence fields\"]\n        DragDrop[\"_handleDrop() + auto-exception\"]\n    end\n\n    DB --> LoadEvents\n    LoadEvents --> EventStore\n    LoadEvents --> ExceptionStore\n    EventStore --> Expander\n    Expander --> ExApplicator\n    ExceptionStore --> ExApplicator\n    ExApplicator --> ExpansionCache\n    ExpansionCache --> RangeQuery\n    RangeQuery --> MonthView\n    MonthView --> TileContext\n    DragDrop --> ExceptionStore\n    DragDrop --> ChangeInfo\n    ChangeInfo --> MutationPersist\n```\n\n### Cache Strategy\n\n```mermaid\nflowchart LR\n    subgraph cacheOps [Cache Operations]\n        AddExc[\"addException()\"]\n        RemExc[\"removeException()\"]\n        ModOcc[\"modifyOccurrence()\"]\n        UpdateMaster[\"updateRecurringEvent()\"]\n        RangeChange[\"visible range change\"]\n    end\n\n    subgraph cacheAction [Cache Action]\n        Patch[\"O(1) cache patch\"]\n        InvalidSeries[\"Invalidate series only\"]\n        ExpandNew[\"Expand new range, reuse overlap\"]\n    end\n\n    AddExc --> Patch\n    RemExc --> Patch\n    ModOcc --> Patch\n    UpdateMaster --> InvalidSeries\n    RangeChange --> ExpandNew\n```\n\n## Components and Interfaces\n\n### MCalFrequency (NEW — `lib/src/models/mcal_recurrence_rule.dart`)\n\n```dart\nenum MCalFrequency { daily, weekly, monthly, yearly }\n```\n\n### MCalWeekDay (NEW — `lib/src/models/mcal_recurrence_rule.dart`)\n\n```dart\nclass MCalWeekDay {\n  final int dayOfWeek; // DateTime.monday..DateTime.sunday\n  final int? occurrence; // e.g., 1 = first, -1 = last, null = every\n\n  const MCalWeekDay(this.dayOfWeek, [this.occurrence]);\n\n  // Convenience constructors\n  const MCalWeekDay.every(this.dayOfWeek) : occurrence = null;\n  const MCalWeekDay.nth(this.dayOfWeek, int n) : occurrence = n;\n\n  // == , hashCode, toString, copyWith\n}\n```\n\n### MCalRecurrenceRule (NEW — `lib/src/models/mcal_recurrence_rule.dart`)\n\n```dart\nclass MCalRecurrenceRule {\n  final MCalFrequency frequency;\n  final int interval; // default 1\n  final int? count;\n  final DateTime? until;\n  final Set<MCalWeekDay>? byWeekDays;\n  final Set<int>? byMonthDays;\n  final Set<int>? byMonths;\n  final Set<int>? bySetPositions;\n  final int? weekStart; // DateTime.monday..DateTime.sunday\n\n  const MCalRecurrenceRule({\n    required this.frequency,\n    this.interval = 1,\n    this.count,\n    this.until,\n    this.byWeekDays,\n    this.byMonthDays,\n    this.byMonths,\n    this.bySetPositions,\n    this.weekStart,\n  });\n\n  factory MCalRecurrenceRule.fromRruleString(String rrule);\n  String toRruleString();\n\n  /// Expand occurrences within range. Internally converts to teno_rrule,\n  /// calls between(), and converts back. Handles UTC conversion transparently.\n  List<DateTime> getOccurrences({\n    required DateTime start, // series start (DTSTART)\n    required DateTime after,\n    required DateTime before,\n  });\n\n  // copyWith, ==, hashCode, toString\n}\n```\n\n**Internal conversion** (private, same file):\n```dart\n// Private: converts MCalRecurrenceRule to teno_rrule RecurrenceRule\nRecurrenceRule _toTenoRrule(DateTime dtStart) { ... }\n\n// Private: converts teno_rrule RecurrenceRule to MCalRecurrenceRule\nMCalRecurrenceRule _fromTenoRrule(RecurrenceRule rule) { ... }\n```\n\n### MCalRecurrenceException (NEW — `lib/src/models/mcal_recurrence_exception.dart`)\n\n```dart\nenum MCalExceptionType { deleted, rescheduled, modified }\n\nclass MCalRecurrenceException {\n  final MCalExceptionType type;\n  final DateTime originalDate;\n  final DateTime? newDate; // only for rescheduled\n  final MCalCalendarEvent? modifiedEvent; // only for modified\n\n  const MCalRecurrenceException.deleted({required this.originalDate})\n      : type = MCalExceptionType.deleted,\n        newDate = null,\n        modifiedEvent = null;\n\n  const MCalRecurrenceException.rescheduled({\n    required this.originalDate,\n    required DateTime this.newDate,\n  }) : type = MCalExceptionType.rescheduled,\n       modifiedEvent = null;\n\n  const MCalRecurrenceException.modified({\n    required this.originalDate,\n    required MCalCalendarEvent this.modifiedEvent,\n  }) : type = MCalExceptionType.modified,\n       newDate = null;\n\n  // copyWith, ==, hashCode, toString\n}\n```\n\n### MCalEventChangeInfo (NEW — `lib/src/models/mcal_event_change_info.dart`)\n\n```dart\nenum MCalChangeType {\n  eventAdded,\n  eventUpdated,\n  eventRemoved,\n  exceptionAdded,\n  exceptionRemoved,\n  seriesSplit,\n  bulkChange,\n}\n\nclass MCalEventChangeInfo {\n  final MCalChangeType type;\n  final Set<String> affectedEventIds;\n  final DateTimeRange? affectedDateRange;\n\n  const MCalEventChangeInfo({\n    required this.type,\n    required this.affectedEventIds,\n    this.affectedDateRange,\n  });\n}\n```\n\n### MCalCalendarEvent (MODIFIED — `lib/src/models/mcal_calendar_event.dart`)\n\n- **New field**: `final MCalRecurrenceRule? recurrenceRule;`\n- **Constructor**: Add `this.recurrenceRule` optional parameter.\n- **copyWith**: Add `recurrenceRule` parameter. To allow clearing (setting to null), use a sentinel pattern or a nullable wrapper.\n- **==, hashCode**: Include `recurrenceRule`.\n\n### MCalEventController (MODIFIED — `lib/src/controllers/mcal_event_controller.dart`)\n\n#### New Internal State\n\n```dart\n// Exception store: seriesId -> {originalDate -> exception}\nfinal Map<String, Map<DateTime, MCalRecurrenceException>> _exceptionsBySeriesId = {};\n\n// Expansion cache: seriesId -> List<MCalCalendarEvent> (expanded for current range)\nfinal Map<String, List<MCalCalendarEvent>> _expandedBySeriesId = {};\n\n// The date range for which _expandedBySeriesId is valid\nDateTimeRange? _expandedRange;\n\n// Last change info for targeted view rebuilds\nMCalEventChangeInfo? _lastChange;\n```\n\n#### Enhanced `getEventsForRange()`\n\n```dart\nList<MCalCalendarEvent> getEventsForRange(DateTimeRange range) {\n  final results = <MCalCalendarEvent>[];\n\n  for (final event in _eventsById.values) {\n    if (event.recurrenceRule != null) {\n      // Get expanded occurrences (from cache or expand fresh)\n      final occurrences = _getExpandedOccurrences(event, range);\n      results.addAll(occurrences);\n    } else {\n      // Existing logic for standalone events\n      if (!event.start.isAfter(range.end) && !event.end.isBefore(range.start)) {\n        results.add(event);\n      }\n    }\n  }\n\n  return results;\n}\n```\n\n#### Private Expansion Method\n\n```dart\nList<MCalCalendarEvent> _getExpandedOccurrences(\n  MCalCalendarEvent master,\n  DateTimeRange range,\n) {\n  // Check cache\n  if (_expandedRange != null &&\n      _expandedBySeriesId.containsKey(master.id) &&\n      _rangeContains(_expandedRange!, range)) {\n    return _expandedBySeriesId[master.id]!\n        .where((e) => !e.start.isAfter(range.end) && !e.end.isBefore(range.start))\n        .toList();\n  }\n\n  // Expand using MCalRecurrenceRule.getOccurrences()\n  final duration = master.end.difference(master.start);\n  final occurrenceDates = master.recurrenceRule!.getOccurrences(\n    start: master.start,\n    after: range.start,\n    before: range.end,\n  );\n\n  final exceptions = _exceptionsBySeriesId[master.id] ?? {};\n  final expanded = <MCalCalendarEvent>[];\n\n  for (final date in occurrenceDates) {\n    final dateKey = _normalizeDate(date);\n    final exception = exceptions[dateKey];\n\n    if (exception != null) {\n      switch (exception.type) {\n        case MCalExceptionType.deleted:\n          continue; // Skip this occurrence\n        case MCalExceptionType.rescheduled:\n          expanded.add(master.copyWith(\n            id: '${master.id}_${dateKey.toIso8601String()}',\n            start: exception.newDate,\n            end: exception.newDate!.add(duration),\n            occurrenceId: dateKey.toIso8601String(),\n          ));\n        case MCalExceptionType.modified:\n          expanded.add(exception.modifiedEvent!.copyWith(\n            occurrenceId: dateKey.toIso8601String(),\n          ));\n      }\n    } else {\n      expanded.add(master.copyWith(\n        id: '${master.id}_${dateKey.toIso8601String()}',\n        start: date,\n        end: date.add(duration),\n        occurrenceId: dateKey.toIso8601String(),\n      ));\n    }\n  }\n\n  // Cache\n  _expandedBySeriesId[master.id] = expanded;\n  return expanded;\n}\n```\n\n#### Exception Methods\n\n```dart\nMCalRecurrenceException addException(String seriesId, MCalRecurrenceException exception) {\n  _exceptionsBySeriesId.putIfAbsent(seriesId, () => {});\n  final dateKey = _normalizeDate(exception.originalDate);\n  _exceptionsBySeriesId[seriesId]![dateKey] = exception;\n\n  // Patch cache in O(1) instead of re-expanding\n  _patchCacheForException(seriesId, exception);\n\n  _lastChange = MCalEventChangeInfo(\n    type: MCalChangeType.exceptionAdded,\n    affectedEventIds: {seriesId},\n    affectedDateRange: _computeAffectedRange(exception),\n  );\n  notifyListeners();\n  return exception;\n}\n\nvoid addExceptions(String seriesId, List<MCalRecurrenceException> exceptions) {\n  _exceptionsBySeriesId.putIfAbsent(seriesId, () => {});\n  for (final ex in exceptions) {\n    _exceptionsBySeriesId[seriesId]![_normalizeDate(ex.originalDate)] = ex;\n  }\n  // Invalidate series cache (batch = re-expand is more efficient than N patches)\n  _expandedBySeriesId.remove(seriesId);\n  _lastChange = MCalEventChangeInfo(\n    type: MCalChangeType.bulkChange,\n    affectedEventIds: {seriesId},\n  );\n  notifyListeners();\n}\n\nMCalRecurrenceException removeException(String seriesId, DateTime originalDate) {\n  final dateKey = _normalizeDate(originalDate);\n  final removed = _exceptionsBySeriesId[seriesId]?.remove(dateKey);\n  if (removed != null) {\n    _patchCacheForExceptionRemoval(seriesId, removed);\n    _lastChange = MCalEventChangeInfo(\n      type: MCalChangeType.exceptionRemoved,\n      affectedEventIds: {seriesId},\n      affectedDateRange: _computeAffectedRange(removed),\n    );\n    notifyListeners();\n  }\n  return removed!;\n}\n\nList<MCalRecurrenceException> getExceptions(String seriesId) {\n  return _exceptionsBySeriesId[seriesId]?.values.toList() ?? [];\n}\n\nMCalRecurrenceException modifyOccurrence(\n  String seriesId,\n  DateTime originalDate,\n  MCalCalendarEvent modifiedEvent,\n) {\n  final exception = MCalRecurrenceException.modified(\n    originalDate: originalDate,\n    modifiedEvent: modifiedEvent,\n  );\n  return addException(seriesId, exception);\n}\n```\n\n#### Series Management Methods\n\n```dart\nvoid updateRecurringEvent(MCalCalendarEvent event) {\n  assert(event.recurrenceRule != null);\n  _eventsById[event.id] = event;\n  _expandedBySeriesId.remove(event.id); // Invalidate this series only\n  _lastChange = MCalEventChangeInfo(\n    type: MCalChangeType.eventUpdated,\n    affectedEventIds: {event.id},\n  );\n  notifyListeners();\n}\n\nvoid deleteRecurringEvent(String eventId) {\n  _eventsById.remove(eventId);\n  _exceptionsBySeriesId.remove(eventId);\n  _expandedBySeriesId.remove(eventId);\n  _lastChange = MCalEventChangeInfo(\n    type: MCalChangeType.eventRemoved,\n    affectedEventIds: {eventId},\n  );\n  notifyListeners();\n}\n\nString splitSeries(String seriesId, DateTime fromDate) {\n  final master = _eventsById[seriesId]!;\n  assert(master.recurrenceRule != null);\n\n  // 1. Truncate original series to end before fromDate\n  final dayBefore = fromDate.subtract(const Duration(days: 1));\n  final truncatedRule = master.recurrenceRule!.copyWith(\n    until: dayBefore,\n    count: null, // clear count, use until instead\n  );\n  _eventsById[seriesId] = master.copyWith(recurrenceRule: truncatedRule);\n\n  // 2. Create new master starting at fromDate\n  final newId = '${seriesId}_split_${fromDate.toIso8601String()}';\n  final duration = master.end.difference(master.start);\n  final newMaster = master.copyWith(\n    id: newId,\n    start: fromDate,\n    end: fromDate.add(duration),\n    recurrenceRule: master.recurrenceRule, // same pattern\n  );\n  _eventsById[newId] = newMaster;\n\n  // 3. Move exceptions on or after fromDate to new series\n  final originalExceptions = _exceptionsBySeriesId[seriesId];\n  if (originalExceptions != null) {\n    final toMove = <DateTime, MCalRecurrenceException>{};\n    originalExceptions.removeWhere((date, ex) {\n      if (!date.isBefore(fromDate)) {\n        toMove[date] = ex;\n        return true;\n      }\n      return false;\n    });\n    if (toMove.isNotEmpty) {\n      _exceptionsBySeriesId[newId] = toMove;\n    }\n  }\n\n  // 4. Invalidate caches for both series\n  _expandedBySeriesId.remove(seriesId);\n  _expandedBySeriesId.remove(newId);\n\n  _lastChange = MCalEventChangeInfo(\n    type: MCalChangeType.seriesSplit,\n    affectedEventIds: {seriesId, newId},\n  );\n  notifyListeners();\n  return newId;\n}\n```\n\n#### Cache Patch Methods (O(1) per exception)\n\n```dart\nvoid _patchCacheForException(String seriesId, MCalRecurrenceException exception) {\n  final cached = _expandedBySeriesId[seriesId];\n  if (cached == null) return;\n\n  final dateKey = _normalizeDate(exception.originalDate);\n\n  switch (exception.type) {\n    case MCalExceptionType.deleted:\n      cached.removeWhere((e) => e.occurrenceId == dateKey.toIso8601String());\n    case MCalExceptionType.rescheduled:\n      final idx = cached.indexWhere((e) => e.occurrenceId == dateKey.toIso8601String());\n      if (idx >= 0) {\n        final master = _eventsById[seriesId]!;\n        final duration = master.end.difference(master.start);\n        cached[idx] = master.copyWith(\n          id: '${seriesId}_${dateKey.toIso8601String()}',\n          start: exception.newDate,\n          end: exception.newDate!.add(duration),\n          occurrenceId: dateKey.toIso8601String(),\n        );\n      }\n    case MCalExceptionType.modified:\n      final idx = cached.indexWhere((e) => e.occurrenceId == dateKey.toIso8601String());\n      if (idx >= 0) {\n        cached[idx] = exception.modifiedEvent!.copyWith(\n          occurrenceId: dateKey.toIso8601String(),\n        );\n      }\n  }\n}\n```\n\n### MCalEventTileContext (MODIFIED — `lib/src/widgets/mcal_month_view_contexts.dart`)\n\nNew fields added to the constructor and class:\n\n```dart\nclass MCalEventTileContext {\n  // ... existing fields ...\n\n  /// True for occurrences of recurring events.\n  final bool isRecurring;\n\n  /// The master event's ID, if this is a recurring occurrence.\n  final String? seriesId;\n\n  /// The recurrence rule from the master event.\n  final MCalRecurrenceRule? recurrenceRule;\n\n  /// The full master event (for accessing original fields).\n  final MCalCalendarEvent? masterEvent;\n\n  /// True if this occurrence has been modified or rescheduled.\n  final bool isException;\n}\n```\n\nPopulation happens in the month view where `MCalEventTileContext` is constructed (in `_WeekRowWidget.build` and related methods). The controller is consulted to determine if an event is a recurring occurrence (by checking `occurrenceId` and looking up the master).\n\n### MCalEventDroppedDetails (MODIFIED — `lib/src/widgets/mcal_callback_details.dart`)\n\n```dart\nclass MCalEventDroppedDetails {\n  // ... existing fields ...\n\n  /// Whether the dropped event is a recurring occurrence.\n  final bool isRecurring;\n\n  /// The master event's ID, if recurring.\n  final String? seriesId;\n}\n```\n\n### Drag-Drop Integration (`_handleDrop` in `mcal_month_view.dart`)\n\nAfter the existing drop logic, before notifying:\n\n```dart\nvoid _handleDrop(DragTargetDetails<MCalDragData> details) {\n  // ... existing drag calculation logic ...\n\n  // Detect if this is a recurring occurrence\n  final isRecurring = event.occurrenceId != null;\n  String? seriesId;\n  if (isRecurring) {\n    seriesId = _extractSeriesId(event.id); // e.g., strip the occurrence suffix\n  }\n\n  // Call onEventDropped with recurrence info\n  if (widget.onEventDropped != null) {\n    final shouldKeep = widget.onEventDropped!(\n      context,\n      MCalEventDroppedDetails(\n        event: event,\n        oldStartDate: event.start,\n        oldEndDate: event.end,\n        newStartDate: newStart,\n        newEndDate: newEnd,\n        isRecurring: isRecurring,\n        seriesId: seriesId,\n      ),\n    );\n\n    if (shouldKeep && isRecurring && seriesId != null) {\n      // Auto-create reschedule exception\n      widget.controller.addException(\n        seriesId,\n        MCalRecurrenceException.rescheduled(\n          originalDate: event.start,\n          newDate: newStart,\n        ),\n      );\n    } else if (shouldKeep && !isRecurring) {\n      // Existing behavior: update event in controller\n      widget.controller.addEvents([updatedEvent]);\n    }\n  }\n}\n```\n\n### Example App Editor\n\n#### File: `example/lib/widgets/recurrence_editor_dialog.dart` (NEW)\n\nA `StatefulWidget` dialog that edits `MCalRecurrenceRule`:\n\n- **Frequency picker**: `SegmentedButton<MCalFrequency>` or `DropdownButton`\n- **Interval input**: `TextFormField` with number keyboard\n- **Day-of-week selector**: `FilterChip` row for Mon-Sun (shown when frequency = weekly)\n- **Day-of-month selector**: `Wrap` of number chips 1-31 (shown when frequency = monthly)\n- **End condition**: Radio group (Never / After N occurrences / Until date) with appropriate inputs\n- **Week start**: `DropdownButton` (Mon-Sun)\n- Returns `MCalRecurrenceRule?` via `Navigator.pop`\n\n#### File: `example/lib/widgets/recurrence_edit_scope_dialog.dart` (NEW)\n\nSimple dialog presented when editing a recurring occurrence:\n- Three `ListTile` options: \"This event\", \"This and following events\", \"All events\"\n- Returns an enum value via `Navigator.pop`\n\n#### Integration into Features Demo\n\nThe existing Features demo's event tap handler is enhanced:\n- On event tap → show an edit dialog that includes the recurrence editor\n- On event long-press → show delete confirmation, with \"This event\" / \"All events\" options for recurring events\n- New \"Create Recurring Event\" button in the control panel\n\n## Data Models\n\n### Occurrence ID Scheme\n\nEach expanded occurrence gets a deterministic ID and occurrenceId:\n- `id`: `\"{masterEventId}_{normalizedDateIso8601}\"` — e.g., `\"event-1_2024-06-15T00:00:00.000\"`\n- `occurrenceId`: `normalizedDateIso8601` — e.g., `\"2024-06-15T00:00:00.000\"`\n\nThe `_normalizeDate()` helper strips time components for all-day events and normalizes to midnight for consistent keying.\n\n### Exception Keying\n\nExceptions are keyed by `_normalizeDate(originalDate)` within each series. This ensures that looking up whether an occurrence has an exception is O(1).\n\n## Error Handling\n\n### Error Scenarios\n\n1. **`count` and `until` both provided**\n   - **Handling**: `MCalRecurrenceRule` constructor throws `ArgumentError`\n   - **User Impact**: Developer gets immediate, clear error at construction time\n\n2. **Unsupported frequency in RRULE string**\n   - **Handling**: `fromRruleString` throws `ArgumentError` with message listing supported frequencies\n   - **User Impact**: Developer gets clear error at parse time\n\n3. **Exception for non-existent series**\n   - **Handling**: `addException` with unknown `seriesId` stores the exception silently (the master may be loaded later via `loadEvents`)\n   - **User Impact**: None — exception is applied when the master is loaded\n\n4. **Exception date doesn't match any occurrence**\n   - **Handling**: Silently ignored during expansion (no matching occurrence to patch)\n   - **User Impact**: None\n\n5. **`splitSeries` with non-recurring event**\n   - **Handling**: Throws `ArgumentError`\n   - **User Impact**: Developer gets immediate error\n\n## Testing Strategy\n\n### Unit Testing\n\n- **`MCalRecurrenceRule`**: Construction, validation, `fromRruleString`/`toRruleString` round-trip, `getOccurrences` for each frequency, `byWeekDays`/`byMonthDays`/`byMonths` filtering, `weekStart` behavior, `copyWith`/`==`/`hashCode`.\n- **`MCalRecurrenceException`**: Construction, named constructors, `copyWith`/`==`/`hashCode`.\n- **`MCalEventController` expansion**: Expand daily/weekly/monthly/yearly, apply delete/reschedule/modified exceptions, cache hit/miss, granular cache patch, `splitSeries`, `getExceptions`, `lastChange` metadata.\n- **`MCalCalendarEvent`**: New `recurrenceRule` field in `copyWith`/`==`/`hashCode`.\n\n### Integration Testing\n\n- **Month view with recurring events**: Add recurring events to controller, verify they appear on correct dates in the month grid.\n- **Drag-and-drop recurring occurrence**: Drag occurrence to new date, verify exception created and occurrence moves.\n- **Context enrichment**: Verify `MCalEventTileContext` has correct recurrence metadata for recurring occurrences and null/false for standalone events.\n\n### End-to-End Testing\n\n- **Example app**: Create recurring event via editor, verify occurrences display, edit single occurrence, delete occurrence, split series, verify all changes reflect correctly.\n",
  "fileStats": {
    "size": 24561,
    "lines": 707,
    "lastModified": "2026-02-12T04:38:23.956Z"
  },
  "comments": []
}