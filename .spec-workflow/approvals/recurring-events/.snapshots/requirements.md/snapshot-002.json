{
  "id": "snapshot_1770870941574_9helrzqbs",
  "approvalId": "approval_1770869175482_5xipq8wan",
  "approvalTitle": "Requirements: Recurring Events",
  "version": 2,
  "timestamp": "2026-02-12T04:35:41.574Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Requirements Document: Recurring Events\n\n## Introduction\n\nThis specification adds full recurring event support to the multi_calendar package. Recurrence rules are wrapped behind package-owned types (`MCalRecurrenceRule`, `MCalFrequency`, `MCalWeekDay`, `MCalRecurrenceException`) that internally use the `teno_rrule` package for RFC 5545 compliant expansion. The `MCalEventController` is enhanced to automatically expand recurring master events into individual occurrences for the visible date range, apply exceptions (deletions, reschedules, full overrides), and support series splitting. Builder contexts are enriched with recurrence metadata so consuming UIs can distinguish recurring occurrences from standalone events. A full-featured recurrence editor is added to the example app (not part of the package) to demonstrate the API.\n\n## Alignment with Product Vision\n\n* **RFC 5545 RRULE Support**: The product vision lists full RFC 5545 compliance as a key feature. This spec delivers on that promise.\n* **Delegation for Storage**: The package handles recurrence expansion and display but does not persist events — consistent with the delegation pattern.\n* **Customization First**: Recurrence metadata is exposed through builder contexts, giving developers full control over how recurring events are rendered.\n* **Performance Conscious**: Expansion is lazy — only occurrences within the visible date range are generated.\n* **Developer-Friendly**: The wrapper API is simpler than raw RFC 5545, with `MCalRecurrenceRule` providing a clean Dart-native interface.\n\n## Requirements\n\n### Requirement 1: Wrapper Types\n\n**User Story:** As a developer, I want package-owned recurrence types so that my code is not coupled to a third-party RRULE library.\n\n#### Acceptance Criteria\n\n1. The system SHALL provide an `MCalFrequency` enum with values: `daily`, `weekly`, `monthly`, `yearly`.\n2. The system SHALL provide an `MCalWeekDay` class with a `dayOfWeek` field (int, using Dart's `DateTime.monday` through `DateTime.sunday` constants) and an optional `occurrence` field (int, e.g., `1` = first, `-1` = last, used for patterns like \"first Friday\" or \"last Monday\").\n3. The system SHALL provide an immutable `MCalRecurrenceRule` class with the following fields:\n   - `frequency` (`MCalFrequency`, required)\n   - `interval` (`int`, default 1)\n   - `count` (`int?`, optional — number of occurrences)\n   - `until` (`DateTime?`, optional — end date, mutually exclusive with `count`)\n   - `byWeekDays` (`Set<MCalWeekDay>?`, optional)\n   - `byMonthDays` (`Set<int>?`, optional — day numbers, negative values count from end)\n   - `byMonths` (`Set<int>?`, optional — month numbers 1-12)\n   - `bySetPositions` (`Set<int>?`, optional — for complex patterns like \"second-to-last weekday\")\n   - `weekStart` (`int?`, optional — first day of week, defaults to `DateTime.monday`)\n4. `MCalRecurrenceRule` SHALL provide a `factory MCalRecurrenceRule.fromRruleString(String rrule)` constructor that parses an RFC 5545 RRULE string.\n5. `MCalRecurrenceRule` SHALL provide a `String toRruleString()` method that serializes to an RFC 5545 RRULE string.\n6. `MCalRecurrenceRule` SHALL provide a `List<DateTime> getOccurrences({required DateTime after, required DateTime before})` method that returns all occurrence dates within the specified range.\n7. `MCalRecurrenceRule` SHALL provide `copyWith()`, `==`, `hashCode`, and `toString()` implementations.\n8. The system SHALL provide an `MCalExceptionType` enum with values: `deleted`, `rescheduled`, `modified`.\n9. The system SHALL provide an immutable `MCalRecurrenceException` class with:\n   - `type` (`MCalExceptionType`, required)\n   - `originalDate` (`DateTime`, required — the occurrence date being excepted)\n   - `newDate` (`DateTime?`, optional — only for `rescheduled` type)\n   - `modifiedEvent` (`MCalCalendarEvent?`, optional — only for `modified` type, the full replacement event for this occurrence)\n10. `MCalRecurrenceException` SHALL provide `copyWith()`, `==`, `hashCode`, and `toString()` implementations.\n11. All wrapper types SHALL be defined in new files under `lib/src/models/` and exported from `lib/multi_calendar.dart`.\n12. The internal `teno_rrule` package SHALL NOT be exposed in any public API. All public types are package-owned.\n\n### Requirement 2: Event Model Changes\n\n**User Story:** As a developer, I want to create recurring events using the same `MCalCalendarEvent` model so that the API remains simple and consistent.\n\n#### Acceptance Criteria\n\n1. `MCalCalendarEvent` SHALL gain an optional `MCalRecurrenceRule? recurrenceRule` field.\n2. WHEN `recurrenceRule` is non-null THEN the event is a \"master\" event representing the series. The `start` and `end` fields define the first occurrence's timing and the duration template for all occurrences.\n3. WHEN `recurrenceRule` is null THEN the event is a standalone (non-recurring) event, preserving full backward compatibility.\n4. The `copyWith()` method SHALL be updated to include `recurrenceRule`.\n5. The `==` and `hashCode` implementations SHALL include `recurrenceRule`.\n\n### Requirement 3: Controller Expansion Engine\n\n**User Story:** As a developer, I want the controller to automatically expand recurring events into individual occurrences for the visible date range so that I don't have to implement expansion logic myself.\n\n#### Acceptance Criteria\n\n1. WHEN `getEventsForRange()` is called THEN the controller SHALL expand all master events (events with non-null `recurrenceRule`) into individual occurrence `MCalCalendarEvent` instances whose `start`/`end` dates fall within or overlap the requested range.\n2. Each expanded occurrence SHALL be an `MCalCalendarEvent` with:\n   - `id` set to `\"{masterEventId}_{occurrenceIndex}\"` or a deterministic scheme based on the occurrence date\n   - `start` and `end` adjusted to the occurrence date while preserving the original duration\n   - `occurrenceId` set to uniquely identify this occurrence (e.g., ISO 8601 date string of the occurrence start)\n   - All other fields copied from the master event (title, color, isAllDay, comment, externalId)\n3. The controller SHALL cache expanded occurrences for the current visible range. Cache management SHALL be granular:\n   - Single-occurrence exception operations (add/remove/modify exception) SHALL patch the cache in place (O(1) per occurrence) rather than re-expanding the entire series.\n   - Master event changes (updateRecurringEvent, deleteRecurringEvent) SHALL invalidate only that series' cached occurrences, not all cached data.\n   - Adding a new recurring event SHALL expand only the new series for the cached range.\n4. Non-recurring events SHALL continue to work exactly as before — no behavioral change for events without a `recurrenceRule`.\n5. The controller SHALL pass `weekStart` from the `MCalRecurrenceRule` to the underlying `teno_rrule` expansion engine so that WEEKLY recurrences respect the configured week start.\n6. Expansion SHALL be lazy — only occurrences within the requested range are generated, not the full infinite series.\n\n### Requirement 4: Exception Handling\n\n**User Story:** As a developer, I want to manage exceptions to individual occurrences (delete, reschedule, or fully override) so that users can customize specific instances of a recurring series.\n\n#### Acceptance Criteria\n\n1. The controller SHALL provide `addException(String seriesId, MCalRecurrenceException exception)` to register an exception for a specific occurrence.\n2. The controller SHALL provide `removeException(String seriesId, DateTime originalDate)` to remove a previously registered exception.\n3. The controller SHALL provide `getExceptions(String seriesId)` to retrieve all exceptions for a series.\n4. WHEN an exception of type `deleted` exists for an occurrence date THEN that occurrence SHALL be excluded from `getEventsForRange()` results.\n5. WHEN an exception of type `rescheduled` exists THEN the occurrence SHALL appear at the `newDate` instead of `originalDate`, preserving all other fields from the master event.\n6. WHEN an exception of type `modified` exists THEN the occurrence SHALL be replaced entirely by `modifiedEvent`, with the original occurrence removed. The `modifiedEvent` SHALL have its `occurrenceId` set to identify it as belonging to the series.\n7. The controller SHALL provide a convenience method `modifyOccurrence(String seriesId, DateTime originalDate, MCalCalendarEvent modifiedEvent)` that creates a `modified` exception.\n8. Exceptions SHALL be stored separately from the master event in the controller's internal state.\n9. Adding, removing, or modifying exceptions SHALL trigger `notifyListeners()` to refresh views.\n10. Exception operations SHALL NOT require the consuming application to reload events from its external data source. The controller SHALL handle exception state locally. The consumer is only responsible for persisting the exception to their backend asynchronously.\n\n### Requirement 5: Series Management\n\n**User Story:** As a developer, I want CRUD operations and series splitting so that I can fully manage recurring event lifecycles.\n\n#### Acceptance Criteria\n\n1. The controller SHALL provide `addRecurringEvent(MCalCalendarEvent event)` that adds a master event with a `recurrenceRule`. This MAY be the same as `addEvents()` — the controller detects recurring events automatically.\n2. The controller SHALL provide `updateRecurringEvent(MCalCalendarEvent event)` that replaces the master event, invalidates cached expansions, and preserves existing exceptions.\n3. The controller SHALL provide `deleteRecurringEvent(String eventId)` that removes the master event and all associated exceptions.\n4. The controller SHALL provide `splitSeries(String seriesId, DateTime fromDate)` that:\n   - Modifies the original master event's `recurrenceRule` to end before `fromDate` (by setting `until` to the day before `fromDate`)\n   - Creates a new master event starting from `fromDate` with the same recurrence pattern\n   - Moves exceptions on or after `fromDate` to the new series\n   - Returns the new master event's ID\n5. `splitSeries` SHALL trigger `notifyListeners()` after completing.\n\n### Requirement 6: Context Enrichment for Builders\n\n**User Story:** As a developer, I want builder callbacks to receive recurrence metadata so that I can render recurring events differently (e.g., show a recurrence icon, display series info).\n\n#### Acceptance Criteria\n\n1. `MCalEventTileContext` SHALL gain the following optional fields:\n   - `bool isRecurring` (default `false`) — `true` for occurrences of recurring events\n   - `String? seriesId` — the master event's ID\n   - `MCalRecurrenceRule? recurrenceRule` — the recurrence rule from the master event\n   - `MCalCalendarEvent? masterEvent` — the full master event (for accessing original title, color, etc.)\n   - `bool isException` (default `false`) — `true` if this occurrence has been modified or rescheduled\n2. The month view SHALL populate these fields when constructing `MCalEventTileContext` for expanded occurrences.\n3. For non-recurring events, all recurrence-related fields SHALL be null/false, preserving backward compatibility.\n4. `MCalDayCellContext` SHALL continue to receive the expanded occurrence list in its `events` field (including recurring occurrences), requiring no changes to `MCalDayCellContext` itself.\n\n### Requirement 7: Drag-and-Drop Integration\n\n**User Story:** As a developer, I want drag-and-drop on recurring event occurrences to automatically create reschedule exceptions so that the interaction is seamless.\n\n#### Acceptance Criteria\n\n1. WHEN a user drags and drops a recurring event occurrence to a new date THEN the controller SHALL automatically create a `rescheduled` exception for that occurrence.\n2. The `onEventDropped` callback SHALL still be invoked, and its return value SHALL still control whether the drop is accepted.\n3. The `MCalEventDroppedDetails` (or equivalent callback details) SHALL include `isRecurring` and `seriesId` fields so the consuming app can distinguish recurring drops from standalone drops.\n4. IF the consuming app returns `false` from `onEventDropped` THEN no exception SHALL be created.\n\n### Requirement 8: Example App Editor UI\n\n**User Story:** As a developer evaluating the package, I want a full-featured recurrence editor in the example app so that I can see how the recurrence API works in practice.\n\n#### Acceptance Criteria\n\n1. The example app SHALL provide a recurrence editor dialog (not part of the package) with:\n   - Frequency picker (daily, weekly, monthly, yearly)\n   - Interval input (e.g., \"every 2 weeks\")\n   - Day-of-week selector (for weekly frequency — checkboxes for Mon through Sun)\n   - Day-of-month selector (for monthly frequency)\n   - End condition selector: never, after N occurrences, until a specific date\n   - Week start selector\n2. The editor SHALL support creating new recurring events and editing existing ones.\n3. WHEN editing a recurring event occurrence THEN the editor SHALL present a dialog with three options: \"This event\", \"This and following events\", \"All events\".\n   - \"This event\" → creates an exception for the single occurrence\n   - \"This and following events\" → calls `splitSeries` and modifies the new series\n   - \"All events\" → updates the master event\n4. The editor SHALL display a list of exceptions for the series and allow deleting individual exceptions.\n5. The editor SHALL support deleting occurrences (creating `deleted` exceptions) via a delete button on each event.\n6. The editor UI SHALL follow Material Design guidelines and match the existing example app styling.\n\n### Requirement 10: Efficient Change Notifications\n\n**User Story:** As a developer, I want the controller to provide information about what changed so that my UI can perform targeted updates instead of full re-renders, especially important for apps with hundreds of recurring events.\n\n#### Acceptance Criteria\n\n1. The controller SHALL expose a `MCalEventChangeInfo? lastChange` property that describes the most recent mutation. This is set before `notifyListeners()` is called and cleared on the next mutation.\n2. `MCalEventChangeInfo` SHALL include:\n   - `type` (`MCalChangeType` enum: `eventAdded`, `eventUpdated`, `eventRemoved`, `exceptionAdded`, `exceptionRemoved`, `seriesSplit`, `bulkChange`)\n   - `affectedEventIds` (`Set<String>` — the master event IDs or standalone event IDs affected)\n   - `affectedDateRange` (`DateTimeRange?` — the date range where visible changes occurred, enabling views to skip rebuilding unaffected regions)\n3. WHEN a single-occurrence exception is added (e.g., from a drag-drop reschedule) THEN `affectedDateRange` SHALL cover only the original date and the new date (if rescheduled), not the entire series range.\n4. WHEN `addEvents()` or `clearEvents()` is called with many events THEN `type` SHALL be `bulkChange` and `affectedDateRange` SHALL be null (indicating views should fully rebuild).\n5. Views MAY use `lastChange` to optimize rebuilds. Views that do not check `lastChange` SHALL still work correctly (full rebuild on every `notifyListeners()`).\n\n### Requirement 11: RFC 5545 String Interop\n\n**User Story:** As a developer, I want to import and export recurrence rules as RFC 5545 strings so that my app can interoperate with other calendar systems.\n\n#### Acceptance Criteria\n\n1. `MCalRecurrenceRule.fromRruleString(String)` SHALL parse standard RFC 5545 RRULE strings (e.g., `\"RRULE:FREQ=WEEKLY;INTERVAL=2;BYDAY=TU,TH;BYMONTH=12\"`).\n2. `MCalRecurrenceRule.toRruleString()` SHALL produce valid RFC 5545 RRULE strings.\n3. Round-trip conversion (parse → serialize → parse) SHALL produce equivalent rules.\n4. Unsupported frequencies (SECONDLY, MINUTELY, HOURLY) SHALL throw an `ArgumentError` with a clear message when encountered in `fromRruleString`.\n\n### Requirement 12: External Data Source Integration\n\n**User Story:** As a developer using a persistence layer (Drift, SQLite, Firestore, etc.), I want the controller's recurring event API to integrate efficiently with my data loading patterns so that I don't have to load all events upfront or reload everything when a single occurrence changes.\n\n#### Acceptance Criteria\n\n1. The existing `loadEvents(start, end)` override pattern SHALL work seamlessly with recurring events. When a consumer overrides `loadEvents`, they load master events (with `recurrenceRule` set) and exceptions from their database; the controller handles expansion.\n2. The controller SHALL provide `addExceptions(String seriesId, List<MCalRecurrenceException> exceptions)` (batch version) so that consumers can efficiently load all exceptions for a series from their database in one call.\n3. WHEN the visible date range changes (e.g., swipe to next month) THEN the controller SHALL only expand recurring events for the new range, reusing cached occurrences for dates that overlap with the previous range.\n4. The controller SHALL NOT require all events to be loaded in memory simultaneously. The existing `loadEvents` → `addEvents` pattern supports incremental loading, and recurring event expansion SHALL work with whatever subset of master events is currently loaded.\n5. All mutation methods (`addException`, `modifyOccurrence`, `splitSeries`, etc.) SHALL return sufficient information (e.g., the created exception, the new series ID) for the consumer to persist the change to their backend without querying the controller's internal state.\n\n## Non-Functional Requirements\n\n### Code Architecture and Modularity\n\n* **Single Responsibility**: Wrapper types in `lib/src/models/`, expansion logic in the controller, context enrichment in the widget layer, editor UI in `example/`.\n* **Modular Design**: `MCalRecurrenceRule` is a standalone model with no Flutter dependency (pure Dart). The controller bridges models and views.\n* **Dependency Isolation**: `teno_rrule` is imported only in the wrapper implementation files, never in public headers.\n\n### Performance\n\n* Recurrence expansion SHALL be lazy — only occurrences within the requested date range are generated.\n* The controller SHALL cache expanded occurrences for the current visible range. Cache invalidation occurs on master event changes, exception changes, or visible range changes.\n* Expansion of typical recurring events (daily/weekly/monthly for a 3-month range) SHALL complete in under 10ms on mobile devices.\n* Single-occurrence mutations (exception add/remove/modify, drag-drop reschedule) SHALL complete in O(1) time relative to the number of recurring events, by patching the cached expansion rather than re-expanding.\n\n### Reliability\n\n* All existing tests SHALL continue to pass unchanged. Non-recurring events have zero behavioral change.\n* `MCalRecurrenceRule` SHALL be validated on construction: `count` and `until` are mutually exclusive (throw `ArgumentError` if both provided), `interval` must be >= 1.\n* Exception dates that don't match any occurrence SHALL be silently ignored (no error).\n\n### Usability\n\n* The wrapper API should feel native to Dart developers — no UTC conversion required (the wrapper handles `teno_rrule`'s requirements internally).\n* The example editor should be intuitive enough to serve as reference implementation for consuming apps building their own editors.\n",
  "fileStats": {
    "size": 19270,
    "lines": 226,
    "lastModified": "2026-02-12T04:32:52.882Z"
  },
  "comments": []
}