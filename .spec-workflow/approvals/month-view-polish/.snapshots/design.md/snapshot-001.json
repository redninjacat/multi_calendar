{
  "id": "snapshot_1770942491004_dex1kdlqq",
  "approvalId": "approval_1770942490998_j6yt5i0cc",
  "approvalTitle": "Month View Polish - Design Document",
  "version": 1,
  "timestamp": "2026-02-13T00:28:11.004Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Design Document: Month View Polish\n\n## Overview\n\nThis design covers four enhancements to MCalMonthView:\n\n1. **Event edge-drag resizing** — drag the leading/trailing edge of an event tile to change its start/end date.\n2. **System reduced-motion integration** — `enableAnimations` becomes nullable; `null` means \"follow OS preference.\"\n3. **Keyboard-based event moving** — an accessibility alternative to drag-and-drop using arrow keys.\n4. **Multi-day event semantic span labels** — enriched screen-reader labels that include \"N-day event, day M of N.\"\n\nAll four are minimal-footprint changes that build on existing infrastructure (the drag handler, the callback details classes, the localization system, and the event tile widget).\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n\n* **DST-safe arithmetic**: All new date mutations use `DateTime(y, m, d + delta)`, never `Duration(days:)`. Follows the established pattern in `_handleKeyEvent`, `_handleDrop`, and `daysBetween`.\n* **ChangeNotifier reactivity**: Resize state lives in `MCalDragHandler` (already a `ChangeNotifier`), so view rebuilds follow the established drag-and-drop reactive update path.\n* **`intl` localization**: New semantic strings are added to `_enStrings` and `_esMxStrings` in `MCalLocalizations`, following the existing key/value pattern.\n* **flutter_lints**: All new public APIs get full dartdoc.\n\n### Project Structure (structure.md)\n\n* New callback details classes go in `lib/src/widgets/mcal_callback_details.dart` (append to existing file).\n* Resize interaction logic is added to `MCalDragHandler` in `lib/src/widgets/mcal_drag_handler.dart`.\n* Month view parameters and state go in `lib/src/widgets/mcal_month_view.dart`.\n* Localization additions go in `lib/src/utils/mcal_localization.dart`.\n* Tests go in the existing test directories.\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n\n* **`MCalDragHandler`**: Already manages drag state, debounce, edge navigation, proposed drop range, highlighted cells, and change detection. The resize state machine (resizing event, active edge, proposed dates) extends this class with a parallel set of fields gated by an `isResizing` flag — the drag and resize states are mutually exclusive.\n* **Drop target tiles (Layer 3) and overlay (Layer 4)**: The resize preview reuses the exact same `_buildDropTargetTilesLayer` and `_buildDropTargetOverlayLayer` paths. The drag handler's `highlightedCells` and `proposedStartDate`/`proposedEndDate` are set during resize the same way as during drag, so both layers Just Work.\n* **`_handleDrop` flow**: The resize completion flow mirrors `_handleDrop` — calculate new dates, call validation callback, call completion callback, create exception for recurring events, or update event in controller.\n* **`MCalEventTileContext` drag-only fields**: `isDropTargetPreview`, `dropValid`, `proposedStartDate`, `proposedEndDate` are already available for Layer 3 tiles. Resize reuses these.\n* **`_buildDropTargetSemanticLabel`**: Existing semantic label construction for drop targets includes date range. Multi-day event labels will follow the same formatting.\n* **`MCalLocalizations`**: Existing string map infrastructure for `en` and `es_MX`.\n* **`daysBetween` utility**: DST-safe day delta calculation in `lib/src/utils/date_utils.dart`.\n\n### Integration Points\n\n* **`MCalMonthView` parameters**: New parameters (`enableEventResize`, `onResizeWillAccept`, `onEventResized`) follow the exact same pattern as the drag-and-drop parameters.\n* **`MCalEventController`**: For recurring resize, calls `modifyOccurrence` (existing API) which creates a `modified` exception.\n* **`MCalDraggableEventTile`**: Resize handles are added as children of the tile widget, rendered conditionally when resize is enabled.\n\n## Architecture\n\n```mermaid\ngraph TD\n    subgraph \"Requirement 1: Event Resize\"\n        A1[MCalMonthView params<br/>enableEventResize, callbacks] --> A2[MCalDragHandler<br/>resize state machine]\n        A2 --> A3[_EventTileWidget<br/>resize handle affordance]\n        A2 --> A4[Layer 3/4 preview<br/>reuse existing]\n        A2 --> A5[_handleResizeEnd<br/>create exception or update]\n    end\n\n    subgraph \"Requirement 2: Reduced Motion\"\n        B1[enableAnimations: bool?] --> B2[_resolveAnimationsEnabled<br/>MediaQuery check]\n        B2 --> B3[_pageController.animateToPage<br/>or jumpToPage]\n    end\n\n    subgraph \"Requirement 3: Keyboard Move\"\n        C1[_handleKeyEvent] --> C2[Event selection mode]\n        C2 --> C3[Arrow keys: update<br/>drag handler state]\n        C3 --> C4[Enter: confirm via<br/>_handleDrop flow]\n        C3 --> C5[Escape: cancel]\n    end\n\n    subgraph \"Requirement 4: Multi-day Semantics\"\n        D1[_EventTileWidget._getSemanticLabel] --> D2[Check spanLength > 1]\n        D2 --> D3[Append localized span info]\n    end\n```\n\n## Components and Interfaces\n\n### Component 1: Resize State in MCalDragHandler\n\n**Purpose:** Manages the resize interaction lifecycle — tracking which edge is being resized, the original and proposed dates, and the resize validity.\n\n**New fields:**\n```dart\n// Resize state (mutually exclusive with drag state)\nbool _isResizing = false;\nMCalCalendarEvent? _resizingEvent;\nMCalResizeEdge? _resizeEdge;        // start or end\nDateTime? _resizeOriginalStart;\nDateTime? _resizeOriginalEnd;\n\nbool get isResizing => _isResizing;\nMCalCalendarEvent? get resizingEvent => _resizingEvent;\nMCalResizeEdge? get resizeEdge => _resizeEdge;\n```\n\n**New methods:**\n```dart\n/// Begins a resize operation.\nvoid startResize(MCalCalendarEvent event, MCalResizeEdge edge) {\n  _isResizing = true;\n  _resizingEvent = event;\n  _resizeEdge = edge;\n  _resizeOriginalStart = event.start;\n  _resizeOriginalEnd = event.end;\n  notifyListeners();\n}\n\n/// Updates the proposed range during resize.\n/// Uses calendar-day arithmetic: DateTime(y, m, d + delta).\nvoid updateResize({\n  required DateTime proposedStart,\n  required DateTime proposedEnd,\n  required bool isValid,\n  required List<MCalHighlightCellInfo> cells,\n}) {\n  _proposedStartDate = proposedStart;\n  _proposedEndDate = proposedEnd;\n  _isProposedDropValid = isValid;\n  _highlightedCells = cells;\n  notifyListeners();\n}\n\n/// Completes the resize, returning the proposed dates or null if invalid.\n(DateTime start, DateTime end)? completeResize() {\n  if (!_isResizing || !_isProposedDropValid) {\n    cancelResize();\n    return null;\n  }\n  final result = (_proposedStartDate!, _proposedEndDate!);\n  _clearResizeState();\n  return result;\n}\n\n/// Cancels the resize and clears all state.\nvoid cancelResize() {\n  _clearResizeState();\n  notifyListeners();\n}\n\nvoid _clearResizeState() {\n  _isResizing = false;\n  _resizingEvent = null;\n  _resizeEdge = null;\n  _resizeOriginalStart = null;\n  _resizeOriginalEnd = null;\n  _clearProposedDropRange(); // clears highlighted cells, proposed dates\n}\n```\n\n**Dependencies:** None new — extends the existing `MCalDragHandler`.\n**Reuses:** `_highlightedCells`, `_proposedStartDate`, `_proposedEndDate`, `_isProposedDropValid` fields are shared with drag state. Since drag and resize are mutually exclusive, this is safe.\n\n### Component 2: Resize Handle Affordance\n\n**Purpose:** Renders draggable edge handles on event tiles when resizing is enabled.\n\n**Location:** Within the existing tile rendering in `_EventTileWidget` and the Layer 2 week layout builder event tiles in `_MCalMonthViewBody`.\n\n**Design:**\n- Each multi-day event tile segment that is the start-of-span gets a leading-edge handle.\n- Each segment that is the end-of-span gets a trailing-edge handle.\n- Single-day events do NOT get resize handles (already at minimum 1-day duration).\n- The handle is a `GestureDetector` with `onHorizontalDragStart`, `onHorizontalDragUpdate`, `onHorizontalDragEnd` wrapped in a `Positioned` widget on the leading/trailing edge of the tile.\n- The handle width is ~8dp (a narrow strip for pointer interaction). On hover-capable platforms, a subtle visual indicator (vertical line or grip dots) appears on hover.\n- The handle uses `SystemMouseCursors.resizeColumn` on desktop/web to signal resizability.\n\n```dart\n/// A thin draggable zone on the leading or trailing edge of an event tile.\nclass _ResizeHandle extends StatelessWidget {\n  final MCalResizeEdge edge;\n  final MCalCalendarEvent event;\n  final double handleWidth; // 8.0 default\n  final VoidCallback onResizeStart;\n  final ValueChanged<double> onResizeUpdate; // dx delta\n  final VoidCallback onResizeEnd;\n  final VoidCallback onResizeCancel;\n  \n  // builds a Positioned child aligned to start or end edge\n}\n```\n\n**Dependencies:** `MCalDragHandler` for state management.\n**Reuses:** The existing event tile widget tree. Handles are injected as part of a `Stack` wrapping the tile content.\n\n### Component 3: Resize Callback Details\n\n**Purpose:** New detail classes for resize validation and completion callbacks.\n\n**Location:** `lib/src/widgets/mcal_callback_details.dart`\n\n```dart\n/// Which edge of an event is being resized.\nenum MCalResizeEdge { start, end }\n\n/// Details for resize validation (onResizeWillAccept).\nclass MCalResizeWillAcceptDetails {\n  final MCalCalendarEvent event;\n  final DateTime proposedStartDate;\n  final DateTime proposedEndDate;\n  final MCalResizeEdge resizeEdge;\n  \n  const MCalResizeWillAcceptDetails({\n    required this.event,\n    required this.proposedStartDate,\n    required this.proposedEndDate,\n    required this.resizeEdge,\n  });\n}\n\n/// Details for resize completion (onEventResized).\nclass MCalEventResizedDetails {\n  final MCalCalendarEvent event;\n  final DateTime oldStartDate;\n  final DateTime oldEndDate;\n  final DateTime newStartDate;\n  final DateTime newEndDate;\n  final MCalResizeEdge resizeEdge;\n  final bool isRecurring;\n  final String? seriesId;\n  \n  const MCalEventResizedDetails({\n    required this.event,\n    required this.oldStartDate,\n    required this.oldEndDate,\n    required this.newStartDate,\n    required this.newEndDate,\n    required this.resizeEdge,\n    this.isRecurring = false,\n    this.seriesId,\n  });\n}\n```\n\n### Component 4: Resize Interaction in Month View\n\n**Purpose:** Handles the resize gesture lifecycle, preview rendering, and completion.\n\n**Location:** `_MCalMonthViewBody` in `lib/src/widgets/mcal_month_view.dart`\n\n**Design:**\n- When `_ResizeHandle.onResizeStart` fires, the body calls `dragHandler.startResize(event, edge)`.\n- On each `onResizeUpdate`, the body calculates the new proposed date using:\n  ```dart\n  // DST-safe calendar-day arithmetic\n  final dayDelta = (dxAccumulated / dayWidth).round();\n  final DateTime newDate;\n  if (edge == MCalResizeEdge.start) {\n    newDate = DateTime(\n      originalStart.year,\n      originalStart.month,\n      originalStart.day + dayDelta,\n    );\n    // Enforce minimum: newDate must be before end date\n    proposedStart = newDate.isBefore(originalEnd) ? newDate : DateTime(\n      originalEnd.year, originalEnd.month, originalEnd.day,\n    );\n    proposedEnd = originalEnd;\n  } else {\n    newDate = DateTime(\n      originalEnd.year,\n      originalEnd.month,\n      originalEnd.day + dayDelta,\n    );\n    // Enforce minimum: newDate must be after start date\n    proposedEnd = newDate.isAfter(originalStart) ? newDate : DateTime(\n      originalStart.year, originalStart.month, originalStart.day,\n    );\n    proposedStart = originalStart;\n  }\n  ```\n- Calls `onResizeWillAccept` to validate the proposed range.\n- Updates `dragHandler.updateResize(...)` which sets `highlightedCells`, causing Layer 3/4 to render the preview.\n- On `onResizeEnd`, calls `_handleResizeEnd()` which mirrors `_handleDrop()`:\n  - Gets the final proposed dates from `dragHandler.completeResize()`.\n  - Calls `onEventResized` callback.\n  - For recurring occurrences: creates a `modified` exception via `controller.modifyOccurrence(seriesId, originalDate, updatedEvent)`.\n  - For non-recurring events: calls `controller.addEvents([updatedEvent])`.\n- No cross-month edge navigation during resize.\n\n### Component 5: Platform-Aware Auto-Enable\n\n**Purpose:** Determines whether resize should be auto-enabled based on platform.\n\n**Location:** `_MCalMonthViewBody` (computed once in `didChangeDependencies`).\n\n```dart\nbool _resolveEnableResize() {\n  // Explicit override takes precedence\n  if (widget.enableEventResize != null) return widget.enableEventResize!;\n  \n  // Auto-detect: enabled on web, desktop, and tablets; disabled on phones\n  if (kIsWeb) return true;\n  \n  final platform = Theme.of(context).platform;\n  if (platform == TargetPlatform.macOS ||\n      platform == TargetPlatform.windows ||\n      platform == TargetPlatform.linux) {\n    return true;\n  }\n  \n  // Mobile: enabled on tablets (shortest side >= 600dp)\n  final size = MediaQuery.sizeOf(context);\n  final shortestSide = size.shortestSide;\n  return shortestSide >= 600;\n}\n```\n\n### Component 6: Refactored Animation Control\n\n**Purpose:** `enableAnimations` becomes `bool?` with OS-aware defaulting.\n\n**Location:** `MCalMonthView` parameter and `_MCalMonthViewState`/`_MCalMonthViewBody`.\n\n**Current code:**\n```dart\nfinal bool enableAnimations; // defaults to true\n// ...\nthis.enableAnimations = true,\n```\n\n**New code:**\n```dart\nfinal bool? enableAnimations; // defaults to null (OS-aware)\n// ...\nthis.enableAnimations,\n```\n\n**Resolution logic (computed in build):**\n```dart\nbool _resolveAnimationsEnabled(BuildContext context) {\n  // Explicit true/false overrides everything\n  if (widget.enableAnimations != null) return widget.enableAnimations!;\n  \n  // null = follow OS reduced motion preference\n  final features = MediaQuery.accessibilityFeaturesOf(context);\n  return !features.reduceMotion;\n}\n```\n\n**Usage sites that reference `widget.enableAnimations` (currently ~line 1059):**\n```dart\n// Before:\nif (shouldAnimate && widget.enableAnimations) {\n// After:\nif (shouldAnimate && _animationsEnabled) {\n```\n\n`_animationsEnabled` is computed at the top of `build` (or in `didChangeDependencies`) and cached for the frame. The `setDisplayDate(animate: false)` path continues to bypass this via `shouldAnimateNextChange`, unchanged.\n\n### Component 7: Keyboard Event Moving\n\n**Purpose:** Provides an accessible alternative to drag-and-drop for moving events.\n\n**Location:** `_handleKeyEvent` in `_MCalMonthViewBody`.\n\n**State:**\n```dart\n// Keyboard-move mode state\nbool _isKeyboardMoveMode = false;\nMCalCalendarEvent? _keyboardMoveEvent;\nDateTime? _keyboardMoveOriginalStart;\nDateTime? _keyboardMoveOriginalEnd;\n```\n\n**Flow:**\n1. **Enter event selection**: When Enter/Space is pressed on a focused cell, if `enableDragAndDrop` is true and the cell has events, enter selection mode.\n   - If only one event: select it immediately.\n   - If multiple: show a highlighted event and allow Tab/Shift+Tab to cycle. Enter confirms selection.\n2. **Moving**: Arrow keys compute the new position. The system:\n   - Calculates the delta (+1/-1 day for Left/Right, +/-7 for Up/Down).\n   - Sets `dragHandler.startDrag(event, originalDate)` on first move (reusing drag state).\n   - Updates `dragHandler` proposed range and highlighted cells.\n   - Calls `onDragWillAccept` for validation.\n   - Announces \"Moving {title} to {date}\" via `SemanticsService.announce`.\n3. **Confirm**: Enter calls the same `_handleDrop` flow. Announce \"Moved {title} to {date}\".\n4. **Cancel**: Escape clears the keyboard-move state. Announce \"Move cancelled\".\n5. **Month boundary**: When the proposed date moves outside the visible month, navigate to that month (reusing `controller.setDisplayDate`).\n\nThis reuses the existing `MCalDragHandler` state machine entirely — `startDrag`, `updateDrag`, `completeDrag`, `cancelDrag` — with the drag handler not knowing whether the interaction is pointer-based or keyboard-based.\n\n### Component 8: Multi-Day Semantic Span Labels\n\n**Purpose:** Enriches `_EventTileWidget._getSemanticLabel` to include span information.\n\n**Current code (line 4773):**\n```dart\nString _getSemanticLabel() {\n  final localizations = MCalLocalizations();\n  final timeStr = _formatEventTime(localizations);\n  return '${event.title}, $timeStr';\n}\n```\n\n**New code:**\n```dart\nString _getSemanticLabel() {\n  final localizations = MCalLocalizations();\n  final timeStr = _formatEventTime(localizations);\n  \n  if (spanLength > 1) {\n    // Calculate day position within the event span\n    final dayPosition = _calculateDayPosition();\n    final spanStr = localizations.getLocalizedString(\n      'multiDayEventSpan', locale,\n    );\n    // e.g., \"Team Offsite, All day, 3-day event, day 2 of 3\"\n    return '${event.title}, $timeStr, '\n        '$spanLength-${localizations.getLocalizedString('dayUnit', locale)} '\n        '${localizations.getLocalizedString('event', locale)}, '\n        '${localizations.getLocalizedString('day', locale)} '\n        '$dayPosition '\n        '${localizations.getLocalizedString('of', locale)} '\n        '$spanLength';\n  }\n  \n  return '${event.title}, $timeStr';\n}\n\nint _calculateDayPosition() {\n  // Use daysBetween for DST safety\n  final eventStartDate = DateTime(\n    event.start.year, event.start.month, event.start.day,\n  );\n  final cellDate = DateTime(\n    displayDate.year, displayDate.month, displayDate.day,\n  );\n  return daysBetween(eventStartDate, cellDate) + 1;\n}\n```\n\n**New localization keys:**\n```dart\n// English\n'dayUnit': 'day',\n'event': 'event',\n'day': 'day',\n'of': 'of',\n\n// Spanish\n'dayUnit': 'día',\n'event': 'evento',\n'day': 'día',\n'of': 'de',\n```\n\nAlternatively, a simpler approach using a single template string:\n```dart\n// English\n'multiDaySpanLabel': '{days}-day event, day {position} of {days}',\n\n// Spanish\n'multiDaySpanLabel': 'evento de {days} días, día {position} de {days}',\n```\n\nThe simpler template approach is preferred. The implementation will use a `formatMultiDaySpanLabel(int spanLength, int dayPosition, Locale locale)` method on `MCalLocalizations` that does string replacement.\n\n## Data Models\n\n### MCalResizeEdge (enum)\n\n```dart\n/// Which edge of an event tile is being resized.\nenum MCalResizeEdge {\n  /// The start (leading) edge — changing the event's start date.\n  start,\n  /// The end (trailing) edge — changing the event's end date.\n  end,\n}\n```\n\n### MCalResizeWillAcceptDetails\n\n```dart\nclass MCalResizeWillAcceptDetails {\n  final MCalCalendarEvent event;\n  final DateTime proposedStartDate;\n  final DateTime proposedEndDate;\n  final MCalResizeEdge resizeEdge;\n}\n```\n\n### MCalEventResizedDetails\n\n```dart\nclass MCalEventResizedDetails {\n  final MCalCalendarEvent event;\n  final DateTime oldStartDate;\n  final DateTime oldEndDate;\n  final DateTime newStartDate;\n  final DateTime newEndDate;\n  final MCalResizeEdge resizeEdge;\n  final bool isRecurring;\n  final String? seriesId;\n}\n```\n\n## Error Handling\n\n### Error Scenarios\n\n1. **Resize below minimum duration**\n   - **Handling:** `updateResize` enforces `proposedStart <= proposedEnd` using clamping. The highlight shows 1-day minimum.\n   - **User Impact:** The resize handle \"sticks\" at 1 day; no error shown.\n\n2. **Resize callback returns false**\n   - **Handling:** `onEventResized` returns false → event reverts to original dates, controller state is unchanged.\n   - **User Impact:** Event snaps back to original position.\n\n3. **Resize on disposed widget**\n   - **Handling:** All resize timer callbacks check `mounted` before calling `setState`.\n   - **User Impact:** None — gesture is silently dropped.\n\n4. **enableAnimations backward compatibility**\n   - **Handling:** `true` and `false` retain exact previous meaning. Only `null` is new behavior.\n   - **User Impact:** Existing code works identically.\n\n## Testing Strategy\n\n### Unit Testing\n\n- **MCalDragHandler resize state**: `startResize`, `updateResize`, `completeResize`, `cancelResize` — state transitions, mutual exclusivity with drag state.\n- **`_resolveAnimationsEnabled` logic**: `null` with reduceMotion true/false, explicit `true`/`false` overrides.\n- **`_resolveEnableResize` logic**: `null` auto-detect (web, desktop, tablet, phone), explicit overrides.\n- **Multi-day semantic label**: `spanLength=1` → no span info; `spanLength=3` with various positions → correct label.\n- **Localization keys**: New keys present in both `en` and `es_MX` maps.\n\n### Widget Testing\n\n- **Resize interaction**: Simulate horizontal drag on event tile edge → verify handler state updates → verify Layer 3/4 preview → verify callback invoked with correct details.\n- **Resize on recurring event**: Verify `modifyOccurrence` is called with updated event.\n- **Resize minimum enforcement**: Drag past opposite edge → verify clamped to 1 day.\n- **RTL resize**: Leading edge = right side in RTL → verify start date changes.\n- **Keyboard event move**: Focus cell → Enter → Arrow keys → verify handler state → Enter → verify callback.\n- **Reduced motion**: Set `reduceMotion = true` in test MediaQuery → verify `jumpToPage` used instead of `animateToPage`.\n- **enableAnimations override**: Set `enableAnimations = true` with `reduceMotion = true` → verify animation still plays.\n\n### Accessibility Testing\n\n- **Multi-day semantic labels**: Verify screen reader output includes span info.\n- **Keyboard move announcements**: Verify `SemanticsService.announce` calls at each step.\n- **Resize handle semantics**: Verify resize handles have appropriate labels (\"Resize start edge\" / \"Resize end edge\").\n",
  "fileStats": {
    "size": 21291,
    "lines": 544,
    "lastModified": "2026-02-13T00:28:05.444Z"
  },
  "comments": []
}