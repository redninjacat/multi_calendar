{
  "id": "snapshot_1770504613202_x4q95wop0",
  "approvalId": "approval_1770504613187_xtefmuj3n",
  "approvalTitle": "Requirements: Unified Drag Target Architecture",
  "version": 1,
  "timestamp": "2026-02-07T22:50:13.202Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Requirements Document: Unified Drag Target Architecture\n\n## Introduction\n\nThis feature refactors the MCalMonthView drag-and-drop implementation from per-cell DragTarget widgets to a single unified DragTarget that wraps all calendar layers. The current architecture uses individual DragTargets for each day cell, relying on `onWillAcceptWithDetails` to detect when a dragged event crosses cell boundaries. This approach is problematic for multi-day events because boundary detection becomes inconsistent when dragging from various positions within a multi-day event tile.\n\nThe new architecture uses a single DragTarget with `onMove` for continuous position tracking, mathematical cell detection based on pointer coordinates, and a flexible highlight overlay system. This provides more reliable drop target detection, smoother visual feedback, and better performance.\n\n## Alignment with Product Vision\n\nThis feature directly supports several key product principles from product.md:\n\n- **Performance Conscious**: The unified DragTarget with debounced `onMove` reduces widget tree complexity and improves rendering performance during drag operations\n- **Customization First**: The new architecture exposes builder callbacks for the highlight overlay, allowing developers to fully customize drop target visuals\n- **Developer-Friendly**: Mathematical cell detection provides consistent, predictable behavior regardless of where the user initiates the drag on a multi-day event\n- **Mobile-First Design**: Touch-optimized drag-and-drop with smooth 60fps feedback\n\n## Requirements\n\n### Requirement 1: Unified DragTarget Wrapper\n\n**User Story:** As a Flutter developer using MCalMonthView, I want drag-and-drop to work reliably for multi-day events, so that users can drag events from any position and see consistent drop target highlighting.\n\n#### Acceptance Criteria\n\n1. WHEN drag-and-drop is enabled on MCalMonthView THEN the system SHALL wrap all calendar layers (grid, events, overlay) in a single DragTarget widget\n2. WHEN a drag operation begins THEN the system SHALL use the DragTarget's `onMove` callback for continuous position tracking instead of per-cell `onWillAcceptWithDetails`\n3. WHEN a drag enters the calendar area THEN the system SHALL calculate the target cell(s) mathematically based on pointer position, dayWidth, and event duration\n\n### Requirement 2: Mathematical Cell Detection\n\n**User Story:** As a user dragging a multi-day event, I want the drop target highlighting to accurately reflect where my event will land based on the left edge of the dragged tile, so that I can precisely position events.\n\n#### Acceptance Criteria\n\n1. WHEN the user drags an event THEN the system SHALL calculate the drop start cell using: `(pointerLocalX - grabOffsetX - horizontalSpacing) / dayWidth`\n2. WHEN the user drags an N-day event THEN the system SHALL highlight N consecutive cells starting from the calculated drop start cell\n3. WHEN the calculated drop range extends beyond the current week THEN the system SHALL highlight cells across multiple week rows\n4. WHEN the pointer position changes but the calculated drop cell remains the same THEN the system SHALL NOT trigger unnecessary UI updates\n\n### Requirement 3: Debounced Position Updates\n\n**User Story:** As a Flutter developer, I want drag operations to be performant even with frequent pointer movements, so that the calendar maintains smooth 60fps rendering.\n\n#### Acceptance Criteria\n\n1. WHEN `onMove` is called during a drag operation THEN the system SHALL debounce updates using a 16ms time-based threshold\n2. WHEN the debounce timer fires THEN the system SHALL process the most recent pointer position (not intermediate positions)\n3. WHEN no position change occurs within the debounce window THEN the system SHALL NOT trigger any updates\n\n### Requirement 4: Drop Validation Callback\n\n**User Story:** As a Flutter developer, I want to validate whether a proposed drop location is valid before the drop occurs, so that I can enforce business rules (e.g., no events on weekends).\n\n#### Acceptance Criteria\n\n1. WHEN the calculated drop range changes THEN the system SHALL call the `onDragWillAccept` callback (if provided) with `MCalDragWillAcceptDetails` containing the full proposed date range\n2. IF `onDragWillAccept` returns false THEN the system SHALL mark all cells in the drop range as invalid (red highlighting)\n3. IF `onDragWillAccept` returns true OR is not provided THEN the system SHALL mark all cells in the drop range as valid (green highlighting)\n4. WHEN the user releases the drag over an invalid drop range THEN the system SHALL NOT move the event and SHALL clean up the drag state\n\n### Requirement 5: Flexible Highlight Overlay\n\n**User Story:** As a Flutter developer, I want to customize how drop target cells are highlighted, so that the visual feedback matches my app's design system.\n\n#### Acceptance Criteria\n\n1. WHEN drag-and-drop is active THEN the system SHALL render a highlight overlay layer (Layer 3) above the event layer\n2. WHEN no custom builder is provided THEN the system SHALL use a performant default implementation (CustomPainter)\n3. WHEN a custom `dropTargetOverlayBuilder` is provided THEN the system SHALL call the builder to render the overlay\n4. WHEN the overlay is rendered THEN the system SHALL provide the builder with: list of highlighted cells, validity state, dayWidth, and row positions\n\n### Requirement 6: Drop Handling\n\n**User Story:** As a user, I want to drop an event and have it move to exactly where the highlighting indicated, so that the visual feedback matches the actual result.\n\n#### Acceptance Criteria\n\n1. WHEN the user releases a drag THEN the system SHALL immediately cancel any pending edge navigation timers\n2. WHEN the user releases a drag over a valid drop target THEN the system SHALL move the event to the highlighted date range\n3. WHEN the user releases a drag over an invalid drop target THEN the system SHALL NOT move the event and SHALL restore the original state\n4. WHEN the drop is processed THEN the system SHALL call `onEventDropped` callback (if provided) with the old and new date ranges\n\n### Requirement 7: Edge Navigation Integration\n\n**User Story:** As a user dragging an event near the screen edge, I want the calendar to navigate to the previous/next month after a delay, so that I can drop events on dates not currently visible.\n\n#### Acceptance Criteria\n\n1. WHEN the pointer is near the left edge during drag AND `dragEdgeNavigationEnabled` is true THEN the system SHALL start the edge navigation timer for previous month\n2. WHEN the pointer is near the right edge during drag AND `dragEdgeNavigationEnabled` is true THEN the system SHALL start the edge navigation timer for next month\n3. WHEN the pointer moves away from the edge THEN the system SHALL cancel the edge navigation timer\n4. WHEN the edge navigation timer fires THEN the system SHALL navigate to the appropriate month while maintaining the drag state\n\n### Requirement 8: Drag State Cleanup\n\n**User Story:** As a developer, I want drag state to be properly cleaned up in all scenarios, so that the calendar remains in a consistent state.\n\n#### Acceptance Criteria\n\n1. WHEN the drag leaves the calendar area (`onLeave`) THEN the system SHALL clear all highlight overlays\n2. WHEN the drag is cancelled (e.g., Escape key) THEN the system SHALL clear all drag state and highlights\n3. WHEN the drag completes (valid or invalid) THEN the system SHALL clear all drag state and highlights\n4. WHEN the widget is disposed during an active drag THEN the system SHALL cancel timers and clear state\n\n## Non-Functional Requirements\n\n### Code Architecture and Modularity\n\n- **Single Responsibility Principle**: The drag handling logic should be encapsulated in `MCalDragHandler`, separate from the view widget\n- **Modular Design**: The highlight overlay should be a separate component that can be replaced via builder\n- **Dependency Management**: The unified DragTarget should not require changes to existing event tile or layout code\n- **Clear Interfaces**: New callbacks (`dropTargetOverlayBuilder`) should have well-documented type signatures\n\n### Performance\n\n- Drag operations SHALL maintain 60fps rendering on mid-range mobile devices\n- The debounce mechanism SHALL limit `onMove` processing to maximum 60 times per second\n- The highlight overlay SHALL use efficient rendering (CustomPainter for default, or efficient widget tree for custom)\n- Cell detection calculations SHALL be O(1) complexity\n\n### Reliability\n\n- The system SHALL handle edge cases: drags that start/end outside the calendar, rapid month navigation during drag, widget disposal during drag\n- The system SHALL maintain consistent behavior across iOS, Android, Web, and Desktop platforms\n\n### Usability\n\n- Visual feedback SHALL update within one frame (16ms) of the pointer crossing a cell boundary\n- The highlighted cells SHALL exactly match where the event will land when dropped\n- Invalid drop targets SHALL be clearly distinguished from valid ones (default: red vs green)\n",
  "fileStats": {
    "size": 9052,
    "lines": 132,
    "lastModified": "2026-02-07T22:50:08.580Z"
  },
  "comments": []
}